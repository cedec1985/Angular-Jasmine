{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/cedri/demo/testdemo/src/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\r\n * @license Angular v20.1.7\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport * as i3 from '@angular/common';\nimport { LOCATION_INITIALIZED, ViewportScroller, LocationStrategy, HashLocationStrategy, Location, PathLocationStrategy } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { signal, untracked, inject, ɵINTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER, HostAttributeToken, ɵRuntimeError as _RuntimeError, booleanAttribute, Directive, Attribute, HostBinding, Input, HostListener, EventEmitter, Optional, ContentChildren, Output, Injectable, createEnvironmentInjector, InjectionToken, makeEnvironmentProviders, APP_BOOTSTRAP_LISTENER, Injector, ApplicationRef, provideAppInitializer, ɵperformanceMarkFeature as _performanceMarkFeature, ENVIRONMENT_INITIALIZER, NgZone, SkipSelf, NgModule } from '@angular/core';\nimport { ROUTER_CONFIGURATION, NavigationEnd, isUrlTree, Router, ActivatedRoute, RouterConfigLoader, IMPERATIVE_NAVIGATION, NavigationStart, NavigationSkipped, NavigationSkippedCode, Scroll, UrlSerializer, NavigationTransitions, ROUTES, afterNextNavigation, stringifyEvent, NAVIGATION_ERROR_HANDLER, RoutedComponentInputBinder, INPUT_BINDER, CREATE_VIEW_TRANSITION, createViewTransition, VIEW_TRANSITION_OPTIONS, DefaultUrlSerializer, ChildrenOutletContexts, RouterOutlet, ɵEmptyOutletComponent as _EmptyOutletComponent } from './router2.mjs';\nimport { Subject, of, from } from 'rxjs';\nimport { mergeAll, catchError, filter, concatMap, mergeMap } from 'rxjs/operators';\n\n/**\r\n * @description\r\n *\r\n * When applied to an element in a template, makes that element a link\r\n * that initiates navigation to a route. Navigation opens one or more routed components\r\n * in one or more `<router-outlet>` locations on the page.\r\n *\r\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\r\n * the following creates a static link to the route:\r\n * `<a routerLink=\"/user/bob\">link to user component</a>`\r\n *\r\n * You can use dynamic values to generate the link.\r\n * For a dynamic link, pass an array of path segments,\r\n * followed by the params for each segment.\r\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\r\n * generates a link to `/team/11/user/bob;details=true`.\r\n *\r\n * Multiple static segments can be merged into one term and combined with dynamic segments.\r\n * For example, `['/team/11/user', userName, {details: true}]`\r\n *\r\n * The input that you provide to the link is treated as a delta to the current URL.\r\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\r\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\r\n * `/user/(jim//aux:team)`.\r\n * See {@link Router#createUrlTree} for more information.\r\n *\r\n * @usageNotes\r\n *\r\n * You can use absolute or relative paths in a link, set query parameters,\r\n * control how parameters are handled, and keep a history of navigation states.\r\n *\r\n * ### Relative link paths\r\n *\r\n * The first segment name can be prepended with `/`, `./`, or `../`.\r\n * * If the first segment begins with `/`, the router looks up the route from the root of the\r\n *   app.\r\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\r\n *   looks in the children of the current activated route.\r\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\r\n *\r\n * ### Setting and handling query params and fragments\r\n *\r\n * The following link adds a query parameter and a fragment to the generated URL:\r\n *\r\n * ```html\r\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\r\n *   link to user component\r\n * </a>\r\n * ```\r\n * By default, the directive constructs the new URL using the given query parameters.\r\n * The example generates the link: `/user/bob?debug=true#education`.\r\n *\r\n * You can instruct the directive to handle query parameters differently\r\n * by specifying the `queryParamsHandling` option in the link.\r\n * Allowed values are:\r\n *\r\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\r\n *  - `'preserve'`: Preserve the current query params.\r\n *\r\n * For example:\r\n *\r\n * ```html\r\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\r\n *   link to user component\r\n * </a>\r\n * ```\r\n *\r\n * `queryParams`, `fragment`, `queryParamsHandling`, `preserveFragment`, and `relativeTo`\r\n * cannot be used when the `routerLink` input is a `UrlTree`.\r\n *\r\n * See {@link UrlCreationOptions#queryParamsHandling}.\r\n *\r\n * ### Preserving navigation history\r\n *\r\n * You can provide a `state` value to be persisted to the browser's\r\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\r\n * For example:\r\n *\r\n * ```html\r\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\r\n *   link to user component\r\n * </a>\r\n * ```\r\n *\r\n * Use {@link Router#getCurrentNavigation} to retrieve a saved\r\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\r\n * event:\r\n *\r\n * ```ts\r\n * // Get NavigationStart events\r\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\r\n *   const navigation = router.getCurrentNavigation();\r\n *   tracingService.trace({id: navigation.extras.state.tracingId});\r\n * });\r\n * ```\r\n *\r\n * ### RouterLink compatible custom elements\r\n *\r\n * In order to make a custom element work with routerLink, the corresponding custom\r\n * element must implement the `href` attribute and must list `href` in the array of\r\n * the static property/getter `observedAttributes`.\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\nlet RouterLink = /*#__PURE__*/(() => {\n  class RouterLink {\n    router;\n    route;\n    tabIndexAttribute;\n    renderer;\n    el;\n    locationStrategy;\n    /** @nodoc */\n    reactiveHref = signal(null, ...(ngDevMode ? [{\n      debugName: \"reactiveHref\"\n    }] : []));\n    /**\r\n     * Represents an `href` attribute value applied to a host element,\r\n     * when a host element is an `<a>`/`<area>` tag or a compatible custom element.\r\n     * For other tags, the value is `null`.\r\n     */\n    get href() {\n      return untracked(this.reactiveHref);\n    }\n    /** @deprecated */\n    set href(value) {\n      this.reactiveHref.set(value);\n    }\n    /**\r\n     * Represents the `target` attribute on a host element.\r\n     * This is only used when the host element is\r\n     * an `<a>`/`<area>` tag or a compatible custom element.\r\n     */\n    target;\n    /**\r\n     * Passed to {@link Router#createUrlTree} as part of the\r\n     * `UrlCreationOptions`.\r\n     * @see {@link UrlCreationOptions#queryParams}\r\n     * @see {@link Router#createUrlTree}\r\n     */\n    queryParams;\n    /**\r\n     * Passed to {@link Router#createUrlTree} as part of the\r\n     * `UrlCreationOptions`.\r\n     * @see {@link UrlCreationOptions#fragment}\r\n     * @see {@link Router#createUrlTree}\r\n     */\n    fragment;\n    /**\r\n     * Passed to {@link Router#createUrlTree} as part of the\r\n     * `UrlCreationOptions`.\r\n     * @see {@link UrlCreationOptions#queryParamsHandling}\r\n     * @see {@link Router#createUrlTree}\r\n     */\n    queryParamsHandling;\n    /**\r\n     * Passed to {@link Router#navigateByUrl} as part of the\r\n     * `NavigationBehaviorOptions`.\r\n     * @see {@link NavigationBehaviorOptions#state}\r\n     * @see {@link Router#navigateByUrl}\r\n     */\n    state;\n    /**\r\n     * Passed to {@link Router#navigateByUrl} as part of the\r\n     * `NavigationBehaviorOptions`.\r\n     * @see {@link NavigationBehaviorOptions#info}\r\n     * @see {@link Router#navigateByUrl}\r\n     */\n    info;\n    /**\r\n     * Passed to {@link Router#createUrlTree} as part of the\r\n     * `UrlCreationOptions`.\r\n     * Specify a value here when you do not want to use the default value\r\n     * for `routerLink`, which is the current activated route.\r\n     * Note that a value of `undefined` here will use the `routerLink` default.\r\n     * @see {@link UrlCreationOptions#relativeTo}\r\n     * @see {@link Router#createUrlTree}\r\n     */\n    relativeTo;\n    /** Whether a host element is an `<a>`/`<area>` tag or a compatible custom element. */\n    isAnchorElement;\n    subscription;\n    /** @internal */\n    onChanges = new Subject();\n    applicationErrorHandler = inject(_INTERNAL_APPLICATION_ERROR_HANDLER);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    });\n    constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {\n      this.router = router;\n      this.route = route;\n      this.tabIndexAttribute = tabIndexAttribute;\n      this.renderer = renderer;\n      this.el = el;\n      this.locationStrategy = locationStrategy;\n      // Set the initial href value to whatever exists on the host element already\n      this.reactiveHref.set(inject(new HostAttributeToken('href'), {\n        optional: true\n      }));\n      const tagName = el.nativeElement.tagName?.toLowerCase();\n      this.isAnchorElement = tagName === 'a' || tagName === 'area' || !!(\n      // Avoid breaking in an SSR context where customElements might not be defined.\n      typeof customElements === 'object' &&\n      // observedAttributes is an optional static property/getter on a custom element.\n      // The spec states that this must be an array of strings.\n      customElements.get(tagName)?.observedAttributes?.includes?.('href'));\n      if (!this.isAnchorElement) {\n        this.subscribeToNavigationEventsIfNecessary();\n      } else {\n        this.setTabIndexIfNotOnNativeEl('0');\n      }\n    }\n    subscribeToNavigationEventsIfNecessary() {\n      if (this.subscription !== undefined || !this.isAnchorElement) {\n        return;\n      }\n      // preserving fragment in router state\n      let createSubcription = this.preserveFragment;\n      // preserving or merging with query params in router state\n      const dependsOnRouterState = handling => handling === 'merge' || handling === 'preserve';\n      createSubcription ||= dependsOnRouterState(this.queryParamsHandling);\n      createSubcription ||= !this.queryParamsHandling && !dependsOnRouterState(this.options?.defaultQueryParamsHandling);\n      if (!createSubcription) {\n        return;\n      }\n      this.subscription = this.router.events.subscribe(s => {\n        if (s instanceof NavigationEnd) {\n          this.updateHref();\n        }\n      });\n    }\n    /**\r\n     * Passed to {@link Router#createUrlTree} as part of the\r\n     * `UrlCreationOptions`.\r\n     * @see {@link UrlCreationOptions#preserveFragment}\r\n     * @see {@link Router#createUrlTree}\r\n     */\n    preserveFragment = false;\n    /**\r\n     * Passed to {@link Router#navigateByUrl} as part of the\r\n     * `NavigationBehaviorOptions`.\r\n     * @see {@link NavigationBehaviorOptions#skipLocationChange}\r\n     * @see {@link Router#navigateByUrl}\r\n     */\n    skipLocationChange = false;\n    /**\r\n     * Passed to {@link Router#navigateByUrl} as part of the\r\n     * `NavigationBehaviorOptions`.\r\n     * @see {@link NavigationBehaviorOptions#replaceUrl}\r\n     * @see {@link Router#navigateByUrl}\r\n     */\n    replaceUrl = false;\n    /**\r\n     * Modifies the tab index if there was not a tabindex attribute on the element during\r\n     * instantiation.\r\n     */\n    setTabIndexIfNotOnNativeEl(newTabIndex) {\n      if (this.tabIndexAttribute != null /* both `null` and `undefined` */ || this.isAnchorElement) {\n        return;\n      }\n      this.applyAttributeValue('tabindex', newTabIndex);\n    }\n    /** @docs-private */\n    // TODO(atscott): Remove changes parameter in major version as a breaking change.\n    ngOnChanges(changes) {\n      if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== undefined || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {\n        throw new _RuntimeError(4016 /* RuntimeErrorCode.INVALID_ROUTER_LINK_INPUTS */, 'Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.');\n      }\n      if (this.isAnchorElement) {\n        this.updateHref();\n        this.subscribeToNavigationEventsIfNecessary();\n      }\n      // This is subscribed to by `RouterLinkActive` so that it knows to update when there are changes\n      // to the RouterLinks it's tracking.\n      this.onChanges.next(this);\n    }\n    routerLinkInput = null;\n    /**\r\n     * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.\r\n     *   - **array**: commands to pass to {@link Router#createUrlTree}.\r\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\r\n     *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands\r\n     *     and other inputs that correspond to properties of `UrlCreationOptions`.\r\n     *   - **null|undefined**: effectively disables the `routerLink`\r\n     * @see {@link Router#createUrlTree}\r\n     */\n    set routerLink(commandsOrUrlTree) {\n      if (commandsOrUrlTree == null) {\n        this.routerLinkInput = null;\n        this.setTabIndexIfNotOnNativeEl(null);\n      } else {\n        if (isUrlTree(commandsOrUrlTree)) {\n          this.routerLinkInput = commandsOrUrlTree;\n        } else {\n          this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];\n        }\n        this.setTabIndexIfNotOnNativeEl('0');\n      }\n    }\n    /** @docs-private */\n    onClick(button, ctrlKey, shiftKey, altKey, metaKey) {\n      const urlTree = this.urlTree;\n      if (urlTree === null) {\n        return true;\n      }\n      if (this.isAnchorElement) {\n        if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n          return true;\n        }\n        if (typeof this.target === 'string' && this.target != '_self') {\n          return true;\n        }\n      }\n      const extras = {\n        skipLocationChange: this.skipLocationChange,\n        replaceUrl: this.replaceUrl,\n        state: this.state,\n        info: this.info\n      };\n      // navigateByUrl is mocked frequently in tests... Reduce breakages when adding `catch`\n      this.router.navigateByUrl(urlTree, extras)?.catch(e => {\n        this.applicationErrorHandler(e);\n      });\n      // Return `false` for `<a>` elements to prevent default action\n      // and cancel the native behavior, since the navigation is handled\n      // by the Router.\n      return !this.isAnchorElement;\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n      this.subscription?.unsubscribe();\n    }\n    updateHref() {\n      const urlTree = this.urlTree;\n      this.reactiveHref.set(urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? '' : null);\n    }\n    applyAttributeValue(attrName, attrValue) {\n      const renderer = this.renderer;\n      const nativeElement = this.el.nativeElement;\n      if (attrValue !== null) {\n        renderer.setAttribute(nativeElement, attrName, attrValue);\n      } else {\n        renderer.removeAttribute(nativeElement, attrName);\n      }\n    }\n    get urlTree() {\n      if (this.routerLinkInput === null) {\n        return null;\n      } else if (isUrlTree(this.routerLinkInput)) {\n        return this.routerLinkInput;\n      }\n      return this.router.createUrlTree(this.routerLinkInput, {\n        // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n        // Otherwise, we should use the value provided by the user in the input.\n        relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n        queryParams: this.queryParams,\n        fragment: this.fragment,\n        queryParamsHandling: this.queryParamsHandling,\n        preserveFragment: this.preserveFragment\n      });\n    }\n    static ɵfac = function RouterLink_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterLink)(i0.ɵɵdirectiveInject(Router), i0.ɵɵdirectiveInject(ActivatedRoute), i0.ɵɵinjectAttribute('tabindex'), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.LocationStrategy));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: RouterLink,\n      selectors: [[\"\", \"routerLink\", \"\"]],\n      hostVars: 2,\n      hostBindings: function RouterLink_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function RouterLink_click_HostBindingHandler($event) {\n            return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"href\", ctx.reactiveHref(), i0.ɵɵsanitizeUrlOrResourceUrl)(\"target\", ctx.target);\n        }\n      },\n      inputs: {\n        target: \"target\",\n        queryParams: \"queryParams\",\n        fragment: \"fragment\",\n        queryParamsHandling: \"queryParamsHandling\",\n        state: \"state\",\n        info: \"info\",\n        relativeTo: \"relativeTo\",\n        preserveFragment: [2, \"preserveFragment\", \"preserveFragment\", booleanAttribute],\n        skipLocationChange: [2, \"skipLocationChange\", \"skipLocationChange\", booleanAttribute],\n        replaceUrl: [2, \"replaceUrl\", \"replaceUrl\", booleanAttribute],\n        routerLink: \"routerLink\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return RouterLink;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n *\r\n * @description\r\n *\r\n * Tracks whether the linked route of an element is currently active, and allows you\r\n * to specify one or more CSS classes to add to the element when the linked route\r\n * is active.\r\n *\r\n * Use this directive to create a visual distinction for elements associated with an active route.\r\n * For example, the following code highlights the word \"Bob\" when the router\r\n * activates the associated route:\r\n *\r\n * ```html\r\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\r\n * ```\r\n *\r\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\r\n * added to the anchor tag. If the URL changes, the class is removed.\r\n *\r\n * You can set more than one class using a space-separated string or an array.\r\n * For example:\r\n *\r\n * ```html\r\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\r\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\r\n * ```\r\n *\r\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\r\n *\r\n * ```html\r\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\r\n * true}\">Bob</a>\r\n * ```\r\n *\r\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\r\n * instance to a template variable.\r\n * For example, the following checks the status without assigning any CSS classes:\r\n *\r\n * ```html\r\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\r\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\r\n * </a>\r\n * ```\r\n *\r\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\r\n * For example, the following sets the active-link class on the `<div>`  parent tag\r\n * when the URL is either '/user/jim' or '/user/bob'.\r\n *\r\n * ```html\r\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\r\n *   <a routerLink=\"/user/jim\">Jim</a>\r\n *   <a routerLink=\"/user/bob\">Bob</a>\r\n * </div>\r\n * ```\r\n *\r\n * The `RouterLinkActive` directive can also be used to set the aria-current attribute\r\n * to provide an alternative distinction for active elements to visually impaired users.\r\n *\r\n * For example, the following code adds the 'active' class to the Home Page link when it is\r\n * indeed active and in such case also sets its aria-current attribute to 'page':\r\n *\r\n * ```html\r\n * <a routerLink=\"/\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Home Page</a>\r\n * ```\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\nlet RouterLinkActive = /*#__PURE__*/(() => {\n  class RouterLinkActive {\n    router;\n    element;\n    renderer;\n    cdr;\n    link;\n    links;\n    classes = [];\n    routerEventsSubscription;\n    linkInputChangesSubscription;\n    _isActive = false;\n    get isActive() {\n      return this._isActive;\n    }\n    /**\r\n     * Options to configure how to determine if the router link is active.\r\n     *\r\n     * These options are passed to the `Router.isActive()` function.\r\n     *\r\n     * @see {@link Router#isActive}\r\n     */\n    routerLinkActiveOptions = {\n      exact: false\n    };\n    /**\r\n     * Aria-current attribute to apply when the router link is active.\r\n     *\r\n     * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.\r\n     *\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}\r\n     */\n    ariaCurrentWhenActive;\n    /**\r\n     *\r\n     * You can use the output `isActiveChange` to get notified each time the link becomes\r\n     * active or inactive.\r\n     *\r\n     * Emits:\r\n     * true  -> Route is active\r\n     * false -> Route is inactive\r\n     *\r\n     * ```html\r\n     * <a\r\n     *  routerLink=\"/user/bob\"\r\n     *  routerLinkActive=\"active-link\"\r\n     *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\r\n     * ```\r\n     */\n    isActiveChange = new EventEmitter();\n    constructor(router, element, renderer, cdr, link) {\n      this.router = router;\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.link = link;\n      this.routerEventsSubscription = router.events.subscribe(s => {\n        if (s instanceof NavigationEnd) {\n          this.update();\n        }\n      });\n    }\n    /** @docs-private */\n    ngAfterContentInit() {\n      // `of(null)` is used to force subscribe body to execute once immediately (like `startWith`).\n      of(this.links.changes, of(null)).pipe(mergeAll()).subscribe(_ => {\n        this.update();\n        this.subscribeToEachLinkOnChanges();\n      });\n    }\n    subscribeToEachLinkOnChanges() {\n      this.linkInputChangesSubscription?.unsubscribe();\n      const allLinkChanges = [...this.links.toArray(), this.link].filter(link => !!link).map(link => link.onChanges);\n      this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe(link => {\n        if (this._isActive !== this.isLinkActive(this.router)(link)) {\n          this.update();\n        }\n      });\n    }\n    set routerLinkActive(data) {\n      const classes = Array.isArray(data) ? data : data.split(' ');\n      this.classes = classes.filter(c => !!c);\n    }\n    /** @docs-private */\n    ngOnChanges(changes) {\n      this.update();\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n      this.routerEventsSubscription.unsubscribe();\n      this.linkInputChangesSubscription?.unsubscribe();\n    }\n    update() {\n      if (!this.links || !this.router.navigated) return;\n      queueMicrotask(() => {\n        const hasActiveLinks = this.hasActiveLinks();\n        this.classes.forEach(c => {\n          if (hasActiveLinks) {\n            this.renderer.addClass(this.element.nativeElement, c);\n          } else {\n            this.renderer.removeClass(this.element.nativeElement, c);\n          }\n        });\n        if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {\n          this.renderer.setAttribute(this.element.nativeElement, 'aria-current', this.ariaCurrentWhenActive.toString());\n        } else {\n          this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');\n        }\n        // Only emit change if the active state changed.\n        if (this._isActive !== hasActiveLinks) {\n          this._isActive = hasActiveLinks;\n          this.cdr.markForCheck();\n          // Emit on isActiveChange after classes are updated\n          this.isActiveChange.emit(hasActiveLinks);\n        }\n      });\n    }\n    isLinkActive(router) {\n      const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions :\n      // While the types should disallow `undefined` here, it's possible without strict inputs\n      this.routerLinkActiveOptions.exact || false;\n      return link => {\n        const urlTree = link.urlTree;\n        return urlTree ? router.isActive(urlTree, options) : false;\n      };\n    }\n    hasActiveLinks() {\n      const isActiveCheckFn = this.isLinkActive(this.router);\n      return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);\n    }\n    static ɵfac = function RouterLinkActive_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterLinkActive)(i0.ɵɵdirectiveInject(Router), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(RouterLink, 8));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: RouterLinkActive,\n      selectors: [[\"\", \"routerLinkActive\", \"\"]],\n      contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, RouterLink, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.links = _t);\n        }\n      },\n      inputs: {\n        routerLinkActiveOptions: \"routerLinkActiveOptions\",\n        ariaCurrentWhenActive: \"ariaCurrentWhenActive\",\n        routerLinkActive: \"routerLinkActive\"\n      },\n      outputs: {\n        isActiveChange: \"isActiveChange\"\n      },\n      exportAs: [\"routerLinkActive\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return RouterLinkActive;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Use instead of `'paths' in options` to be compatible with property renaming\r\n */\nfunction isActiveMatchOptions(options) {\n  return !!options.paths;\n}\n\n/**\r\n * @description\r\n *\r\n * Provides a preloading strategy.\r\n *\r\n * @publicApi\r\n */\nclass PreloadingStrategy {}\n/**\r\n * @description\r\n *\r\n * Provides a preloading strategy that preloads all modules as quickly as possible.\r\n *\r\n * ```ts\r\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\r\n * ```\r\n *\r\n * @publicApi\r\n */\nlet PreloadAllModules = /*#__PURE__*/(() => {\n  class PreloadAllModules {\n    preload(route, fn) {\n      return fn().pipe(catchError(() => of(null)));\n    }\n    static ɵfac = function PreloadAllModules_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PreloadAllModules)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PreloadAllModules,\n      factory: PreloadAllModules.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PreloadAllModules;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * @description\r\n *\r\n * Provides a preloading strategy that does not preload any modules.\r\n *\r\n * This strategy is enabled by default.\r\n *\r\n * @publicApi\r\n */\nlet NoPreloading = /*#__PURE__*/(() => {\n  class NoPreloading {\n    preload(route, fn) {\n      return of(null);\n    }\n    static ɵfac = function NoPreloading_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NoPreloading)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NoPreloading,\n      factory: NoPreloading.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NoPreloading;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The preloader optimistically loads all router configurations to\r\n * make navigations into lazily-loaded sections of the application faster.\r\n *\r\n * The preloader runs in the background. When the router bootstraps, the preloader\r\n * starts listening to all navigation events. After every such event, the preloader\r\n * will check if any configurations can be loaded lazily.\r\n *\r\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\r\n *\r\n * @publicApi\r\n */\nlet RouterPreloader = /*#__PURE__*/(() => {\n  class RouterPreloader {\n    router;\n    injector;\n    preloadingStrategy;\n    loader;\n    subscription;\n    constructor(router, injector, preloadingStrategy, loader) {\n      this.router = router;\n      this.injector = injector;\n      this.preloadingStrategy = preloadingStrategy;\n      this.loader = loader;\n    }\n    setUpPreloading() {\n      this.subscription = this.router.events.pipe(filter(e => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {});\n    }\n    preload() {\n      return this.processRoutes(this.injector, this.router.config);\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n    processRoutes(injector, routes) {\n      const res = [];\n      for (const route of routes) {\n        if (route.providers && !route._injector) {\n          route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);\n        }\n        const injectorForCurrentRoute = route._injector ?? injector;\n        const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;\n        // Note that `canLoad` is only checked as a condition that prevents `loadChildren` and not\n        // `loadComponent`. `canLoad` guards only block loading of child routes by design. This\n        // happens as a consequence of needing to descend into children for route matching immediately\n        // while component loading is deferred until route activation. Because `canLoad` guards can\n        // have side effects, we cannot execute them here so we instead skip preloading altogether\n        // when present. Lastly, it remains to be decided whether `canLoad` should behave this way\n        // at all. Code splitting and lazy loading is separate from client-side authorization checks\n        // and should not be used as a security measure to prevent loading of code.\n        if (route.loadChildren && !route._loadedRoutes && route.canLoad === undefined || route.loadComponent && !route._loadedComponent) {\n          res.push(this.preloadConfig(injectorForCurrentRoute, route));\n        }\n        if (route.children || route._loadedRoutes) {\n          res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));\n        }\n      }\n      return from(res).pipe(mergeAll());\n    }\n    preloadConfig(injector, route) {\n      return this.preloadingStrategy.preload(route, () => {\n        let loadedChildren$;\n        if (route.loadChildren && route.canLoad === undefined) {\n          loadedChildren$ = this.loader.loadChildren(injector, route);\n        } else {\n          loadedChildren$ = of(null);\n        }\n        const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap(config => {\n          if (config === null) {\n            return of(void 0);\n          }\n          route._loadedRoutes = config.routes;\n          route._loadedInjector = config.injector;\n          // If the loaded config was a module, use that as the module/module injector going\n          // forward. Otherwise, continue using the current module/module injector.\n          return this.processRoutes(config.injector ?? injector, config.routes);\n        }));\n        if (route.loadComponent && !route._loadedComponent) {\n          const loadComponent$ = this.loader.loadComponent(injector, route);\n          return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n        } else {\n          return recursiveLoadChildren$;\n        }\n      });\n    }\n    static ɵfac = function RouterPreloader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterPreloader)(i0.ɵɵinject(Router), i0.ɵɵinject(i0.EnvironmentInjector), i0.ɵɵinject(PreloadingStrategy), i0.ɵɵinject(RouterConfigLoader));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouterPreloader,\n      factory: RouterPreloader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return RouterPreloader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ROUTER_SCROLLER = /*#__PURE__*/new InjectionToken('');\nlet RouterScroller = /*#__PURE__*/(() => {\n  class RouterScroller {\n    urlSerializer;\n    transitions;\n    viewportScroller;\n    zone;\n    options;\n    routerEventsSubscription;\n    scrollEventsSubscription;\n    lastId = 0;\n    lastSource = IMPERATIVE_NAVIGATION;\n    restoredId = 0;\n    store = {};\n    /** @docs-private */\n    constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {\n      this.urlSerializer = urlSerializer;\n      this.transitions = transitions;\n      this.viewportScroller = viewportScroller;\n      this.zone = zone;\n      this.options = options;\n      // Default both options to 'disabled'\n      options.scrollPositionRestoration ||= 'disabled';\n      options.anchorScrolling ||= 'disabled';\n    }\n    init() {\n      // we want to disable the automatic scrolling because having two places\n      // responsible for scrolling results race conditions, especially given\n      // that browser don't implement this behavior consistently\n      if (this.options.scrollPositionRestoration !== 'disabled') {\n        this.viewportScroller.setHistoryScrollRestoration('manual');\n      }\n      this.routerEventsSubscription = this.createScrollEvents();\n      this.scrollEventsSubscription = this.consumeScrollEvents();\n    }\n    createScrollEvents() {\n      return this.transitions.events.subscribe(e => {\n        if (e instanceof NavigationStart) {\n          // store the scroll position of the current stable navigations.\n          this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n          this.lastSource = e.navigationTrigger;\n          this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n        } else if (e instanceof NavigationEnd) {\n          this.lastId = e.id;\n          this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n        } else if (e instanceof NavigationSkipped && e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {\n          this.lastSource = undefined;\n          this.restoredId = 0;\n          this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n        }\n      });\n    }\n    consumeScrollEvents() {\n      return this.transitions.events.subscribe(e => {\n        if (!(e instanceof Scroll)) return;\n        // a popstate event. The pop state event will always ignore anchor scrolling.\n        if (e.position) {\n          if (this.options.scrollPositionRestoration === 'top') {\n            this.viewportScroller.scrollToPosition([0, 0]);\n          } else if (this.options.scrollPositionRestoration === 'enabled') {\n            this.viewportScroller.scrollToPosition(e.position);\n          }\n          // imperative navigation \"forward\"\n        } else {\n          if (e.anchor && this.options.anchorScrolling === 'enabled') {\n            this.viewportScroller.scrollToAnchor(e.anchor);\n          } else if (this.options.scrollPositionRestoration !== 'disabled') {\n            this.viewportScroller.scrollToPosition([0, 0]);\n          }\n        }\n      });\n    }\n    scheduleScrollEvent(routerEvent, anchor) {\n      var _this = this;\n      this.zone.runOutsideAngular(/*#__PURE__*/_asyncToGenerator(function* () {\n        // The scroll event needs to be delayed until after change detection. Otherwise, we may\n        // attempt to restore the scroll position before the router outlet has fully rendered the\n        // component by executing its update block of the template function.\n        //\n        // #57109 (we need to wait at least a macrotask before scrolling. AfterNextRender resolves in microtask event loop with Zones)\n        // We could consider _also_ waiting for a render promise though one should have already happened or been scheduled by this point\n        // and should definitely happen before rAF/setTimeout.\n        // #53985 (cannot rely solely on setTimeout because a frame may paint before the timeout)\n        yield new Promise(resolve => {\n          setTimeout(resolve);\n          if (typeof requestAnimationFrame !== 'undefined') {\n            requestAnimationFrame(resolve);\n          }\n        });\n        _this.zone.run(() => {\n          _this.transitions.events.next(new Scroll(routerEvent, _this.lastSource === 'popstate' ? _this.store[_this.restoredId] : null, anchor));\n        });\n      }));\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n      this.routerEventsSubscription?.unsubscribe();\n      this.scrollEventsSubscription?.unsubscribe();\n    }\n    static ɵfac = function RouterScroller_Factory(__ngFactoryType__) {\n      i0.ɵɵinvalidFactory();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouterScroller,\n      factory: RouterScroller.ɵfac\n    });\n  }\n  return RouterScroller;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * Sets up providers necessary to enable `Router` functionality for the application.\r\n * Allows to configure a set of routes as well as extra features that should be enabled.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can add a Router to your application:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent, {\r\n *   providers: [provideRouter(appRoutes)]\r\n * });\r\n * ```\r\n *\r\n * You can also enable optional features in the Router by adding functions from the `RouterFeatures`\r\n * type:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes,\r\n *         withDebugTracing(),\r\n *         withRouterConfig({paramsInheritanceStrategy: 'always'}))\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link RouterFeatures}\r\n *\r\n * @publicApi\r\n * @param routes A set of `Route`s to use for the application routing table.\r\n * @param features Optional features to configure additional router behaviors.\r\n * @returns A set of providers to setup a Router.\r\n */\nfunction provideRouter(routes, ...features) {\n  return makeEnvironmentProviders([{\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }, typeof ngDevMode === 'undefined' || ngDevMode ? {\n    provide: ROUTER_IS_PROVIDED,\n    useValue: true\n  } : [], {\n    provide: ActivatedRoute,\n    useFactory: rootRoute,\n    deps: [Router]\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useFactory: getBootstrapListener\n  }, features.map(feature => feature.ɵproviders)]);\n}\nfunction rootRoute(router) {\n  return router.routerState.root;\n}\n/**\r\n * Helper function to create an object that represents a Router feature.\r\n */\nfunction routerFeature(kind, providers) {\n  return {\n    ɵkind: kind,\n    ɵproviders: providers\n  };\n}\n/**\r\n * An Injection token used to indicate whether `provideRouter` or `RouterModule.forRoot` was ever\r\n * called.\r\n */\nconst ROUTER_IS_PROVIDED = /*#__PURE__*/new InjectionToken('', {\n  providedIn: 'root',\n  factory: () => false\n});\nconst routerIsProvidedDevModeCheck = {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => {\n      if (!inject(ROUTER_IS_PROVIDED)) {\n        console.warn('`provideRoutes` was called without `provideRouter` or `RouterModule.forRoot`. ' + 'This is likely a mistake.');\n      }\n    };\n  }\n};\n/**\r\n * Registers a DI provider for a set of routes.\r\n * @param routes The route configuration to provide.\r\n *\r\n * @usageNotes\r\n *\r\n * ```ts\r\n * @NgModule({\r\n *   providers: [provideRoutes(ROUTES)]\r\n * })\r\n * class LazyLoadedChildModule {}\r\n * ```\r\n *\r\n * @deprecated If necessary, provide routes using the `ROUTES` `InjectionToken`.\r\n * @see {@link ROUTES}\r\n * @publicApi\r\n */\nfunction provideRoutes(routes) {\n  return [{\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }, typeof ngDevMode === 'undefined' || ngDevMode ? routerIsProvidedDevModeCheck : []];\n}\n/**\r\n * Enables customizable scrolling behavior for router navigations.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can enable scrolling feature:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withInMemoryScrolling())\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link provideRouter}\r\n * @see {@link ViewportScroller}\r\n *\r\n * @publicApi\r\n * @param options Set of configuration parameters to customize scrolling behavior, see\r\n *     `InMemoryScrollingOptions` for additional information.\r\n * @returns A set of providers for use with `provideRouter`.\r\n */\nfunction withInMemoryScrolling(options = {}) {\n  const providers = [{\n    provide: ROUTER_SCROLLER,\n    useFactory: () => {\n      const viewportScroller = inject(ViewportScroller);\n      const zone = inject(NgZone);\n      const transitions = inject(NavigationTransitions);\n      const urlSerializer = inject(UrlSerializer);\n      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, options);\n    }\n  }];\n  return routerFeature(4 /* RouterFeatureKind.InMemoryScrollingFeature */, providers);\n}\nfunction getBootstrapListener() {\n  const injector = inject(Injector);\n  return bootstrappedComponentRef => {\n    const ref = injector.get(ApplicationRef);\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n    const router = injector.get(Router);\n    const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n    if (injector.get(INITIAL_NAVIGATION) === 1 /* InitialNavigation.EnabledNonBlocking */) {\n      router.initialNavigation();\n    }\n    injector.get(ROUTER_PRELOADER, null, {\n      optional: true\n    })?.setUpPreloading();\n    injector.get(ROUTER_SCROLLER, null, {\n      optional: true\n    })?.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    if (!bootstrapDone.closed) {\n      bootstrapDone.next();\n      bootstrapDone.complete();\n      bootstrapDone.unsubscribe();\n    }\n  };\n}\n/**\r\n * A subject used to indicate that the bootstrapping phase is done. When initial navigation is\r\n * `enabledBlocking`, the first navigation waits until bootstrapping is finished before continuing\r\n * to the activation phase.\r\n */\nconst BOOTSTRAP_DONE = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'bootstrap done indicator' : '', {\n  factory: () => {\n    return new Subject();\n  }\n});\nconst INITIAL_NAVIGATION = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'initial navigation' : '', {\n  providedIn: 'root',\n  factory: () => 1 /* InitialNavigation.EnabledNonBlocking */\n});\n/**\r\n * Configures initial navigation to start before the root component is created.\r\n *\r\n * The bootstrap is blocked until the initial navigation is complete. This should be set in case\r\n * you use [server-side rendering](guide/ssr), but do not enable [hydration](guide/hydration) for\r\n * your application.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can enable this navigation behavior:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withEnabledBlockingInitialNavigation())\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link provideRouter}\r\n *\r\n * @publicApi\r\n * @returns A set of providers for use with `provideRouter`.\r\n */\nfunction withEnabledBlockingInitialNavigation() {\n  const providers = [{\n    provide: INITIAL_NAVIGATION,\n    useValue: 0 /* InitialNavigation.EnabledBlocking */\n  }, provideAppInitializer(() => {\n    const injector = inject(Injector);\n    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());\n    return locationInitialized.then(() => {\n      return new Promise(resolve => {\n        const router = injector.get(Router);\n        const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n        afterNextNavigation(router, () => {\n          // Unblock APP_INITIALIZER in case the initial navigation was canceled or errored\n          // without a redirect.\n          resolve(true);\n        });\n        injector.get(NavigationTransitions).afterPreactivation = () => {\n          // Unblock APP_INITIALIZER once we get to `afterPreactivation`. At this point, we\n          // assume activation will complete successfully (even though this is not\n          // guaranteed).\n          resolve(true);\n          return bootstrapDone.closed ? of(void 0) : bootstrapDone;\n        };\n        router.initialNavigation();\n      });\n    });\n  })];\n  return routerFeature(2 /* RouterFeatureKind.EnabledBlockingInitialNavigationFeature */, providers);\n}\n/**\r\n * Disables initial navigation.\r\n *\r\n * Use if there is a reason to have more control over when the router starts its initial navigation\r\n * due to some complex initialization logic.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can disable initial navigation:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withDisabledInitialNavigation())\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link provideRouter}\r\n *\r\n * @returns A set of providers for use with `provideRouter`.\r\n *\r\n * @publicApi\r\n */\nfunction withDisabledInitialNavigation() {\n  const providers = [provideAppInitializer(() => {\n    inject(Router).setUpLocationChangeListener();\n  }), {\n    provide: INITIAL_NAVIGATION,\n    useValue: 2 /* InitialNavigation.Disabled */\n  }];\n  return routerFeature(3 /* RouterFeatureKind.DisabledInitialNavigationFeature */, providers);\n}\n/**\r\n * Enables logging of all internal navigation events to the console.\r\n * Extra logging might be useful for debugging purposes to inspect Router event sequence.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can enable debug tracing:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withDebugTracing())\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link provideRouter}\r\n *\r\n * @returns A set of providers for use with `provideRouter`.\r\n *\r\n * @publicApi\r\n */\nfunction withDebugTracing() {\n  let providers = [];\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    providers = [{\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const router = inject(Router);\n        return () => router.events.subscribe(e => {\n          // tslint:disable:no-console\n          console.group?.(`Router Event: ${e.constructor.name}`);\n          console.log(stringifyEvent(e));\n          console.log(e);\n          console.groupEnd?.();\n          // tslint:enable:no-console\n        });\n      }\n    }];\n  } else {\n    providers = [];\n  }\n  return routerFeature(1 /* RouterFeatureKind.DebugTracingFeature */, providers);\n}\nconst ROUTER_PRELOADER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router preloader' : '');\n/**\r\n * Allows to configure a preloading strategy to use. The strategy is configured by providing a\r\n * reference to a class that implements a `PreloadingStrategy`.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can configure preloading:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withPreloading(PreloadAllModules))\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link provideRouter}\r\n *\r\n * @param preloadingStrategy A reference to a class that implements a `PreloadingStrategy` that\r\n *     should be used.\r\n * @returns A set of providers for use with `provideRouter`.\r\n *\r\n * @publicApi\r\n */\nfunction withPreloading(preloadingStrategy) {\n  const providers = [{\n    provide: ROUTER_PRELOADER,\n    useExisting: RouterPreloader\n  }, {\n    provide: PreloadingStrategy,\n    useExisting: preloadingStrategy\n  }];\n  return routerFeature(0 /* RouterFeatureKind.PreloadingFeature */, providers);\n}\n/**\r\n * Allows to provide extra parameters to configure Router.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can provide extra configuration options:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withRouterConfig({\r\n *          onSameUrlNavigation: 'reload'\r\n *       }))\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link provideRouter}\r\n *\r\n * @param options A set of parameters to configure Router, see `RouterConfigOptions` for\r\n *     additional information.\r\n * @returns A set of providers for use with `provideRouter`.\r\n *\r\n * @publicApi\r\n */\nfunction withRouterConfig(options) {\n  const providers = [{\n    provide: ROUTER_CONFIGURATION,\n    useValue: options\n  }];\n  return routerFeature(5 /* RouterFeatureKind.RouterConfigurationFeature */, providers);\n}\n/**\r\n * Provides the location strategy that uses the URL fragment instead of the history API.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can use the hash location option:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withHashLocation())\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link provideRouter}\r\n * @see {@link /api/common/HashLocationStrategy HashLocationStrategy}\r\n *\r\n * @returns A set of providers for use with `provideRouter`.\r\n *\r\n * @publicApi\r\n */\nfunction withHashLocation() {\n  const providers = [{\n    provide: LocationStrategy,\n    useClass: HashLocationStrategy\n  }];\n  return routerFeature(6 /* RouterFeatureKind.RouterHashLocationFeature */, providers);\n}\n/**\r\n * Provides a function which is called when a navigation error occurs.\r\n *\r\n * This function is run inside application's [injection context](guide/di/dependency-injection-context)\r\n * so you can use the [`inject`](api/core/inject) function.\r\n *\r\n * This function can return a `RedirectCommand` to convert the error to a redirect, similar to returning\r\n * a `UrlTree` or `RedirectCommand` from a guard. This will also prevent the `Router` from emitting\r\n * `NavigationError`; it will instead emit `NavigationCancel` with code NavigationCancellationCode.Redirect.\r\n * Return values other than `RedirectCommand` are ignored and do not change any behavior with respect to\r\n * how the `Router` handles the error.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can use the error handler option:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withNavigationErrorHandler((e: NavigationError) =>\r\n * inject(MyErrorTracker).trackError(e)))\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @see {@link NavigationError}\r\n * @see {@link /api/core/inject inject}\r\n * @see {@link runInInjectionContext}\r\n *\r\n * @returns A set of providers for use with `provideRouter`.\r\n *\r\n * @publicApi\r\n */\nfunction withNavigationErrorHandler(handler) {\n  const providers = [{\n    provide: NAVIGATION_ERROR_HANDLER,\n    useValue: handler\n  }];\n  return routerFeature(7 /* RouterFeatureKind.NavigationErrorHandlerFeature */, providers);\n}\n/**\r\n * Enables binding information from the `Router` state directly to the inputs of the component in\r\n * `Route` configurations.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can enable the feature:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withComponentInputBinding())\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * The router bindings information from any of the following sources:\r\n *\r\n *  - query parameters\r\n *  - path and matrix parameters\r\n *  - static route data\r\n *  - data from resolvers\r\n *\r\n * Duplicate keys are resolved in the same order from above, from least to greatest,\r\n * meaning that resolvers have the highest precedence and override any of the other information\r\n * from the route.\r\n *\r\n * Importantly, when an input does not have an item in the route data with a matching key, this\r\n * input is set to `undefined`. This prevents previous information from being\r\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\r\n * Default values can be provided with a resolver on the route to ensure the value is always present\r\n * or an input and use an input transform in the component.\r\n *\r\n * @see {@link /guide/components/inputs#input-transforms Input Transforms}\r\n * @returns A set of providers for use with `provideRouter`.\r\n */\nfunction withComponentInputBinding() {\n  const providers = [RoutedComponentInputBinder, {\n    provide: INPUT_BINDER,\n    useExisting: RoutedComponentInputBinder\n  }];\n  return routerFeature(8 /* RouterFeatureKind.ComponentInputBindingFeature */, providers);\n}\n/**\r\n * Enables view transitions in the Router by running the route activation and deactivation inside of\r\n * `document.startViewTransition`.\r\n *\r\n * Note: The View Transitions API is not available in all browsers. If the browser does not support\r\n * view transitions, the Router will not attempt to start a view transition and continue processing\r\n * the navigation as usual.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can enable the feature:\r\n * ```ts\r\n * const appRoutes: Routes = [];\r\n * bootstrapApplication(AppComponent,\r\n *   {\r\n *     providers: [\r\n *       provideRouter(appRoutes, withViewTransitions())\r\n *     ]\r\n *   }\r\n * );\r\n * ```\r\n *\r\n * @returns A set of providers for use with `provideRouter`.\r\n * @see https://developer.chrome.com/docs/web-platform/view-transitions/\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\r\n * @developerPreview 19.0\r\n */\nfunction withViewTransitions(options) {\n  _performanceMarkFeature('NgRouterViewTransitions');\n  const providers = [{\n    provide: CREATE_VIEW_TRANSITION,\n    useValue: createViewTransition\n  }, {\n    provide: VIEW_TRANSITION_OPTIONS,\n    useValue: {\n      skipNextTransition: !!options?.skipInitialTransition,\n      ...options\n    }\n  }];\n  return routerFeature(9 /* RouterFeatureKind.ViewTransitionsFeature */, providers);\n}\n\n/**\r\n * The directives defined in the `RouterModule`.\r\n */\nconst ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, _EmptyOutletComponent];\n/**\r\n * @docsNotRequired\r\n */\nconst ROUTER_FORROOT_GUARD = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router duplicate forRoot guard' : '');\n// TODO(atscott): All of these except `ActivatedRoute` are `providedIn: 'root'`. They are only kept\n// here to avoid a breaking change whereby the provider order matters based on where the\n// `RouterModule`/`RouterTestingModule` is imported. These can/should be removed as a \"breaking\"\n// change in a major version.\nconst ROUTER_PROVIDERS = [Location, {\n  provide: UrlSerializer,\n  useClass: DefaultUrlSerializer\n}, Router, ChildrenOutletContexts, {\n  provide: ActivatedRoute,\n  useFactory: rootRoute,\n  deps: [Router]\n}, RouterConfigLoader,\n// Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can\n// be removed when `provideRoutes` is removed.\ntypeof ngDevMode === 'undefined' || ngDevMode ? {\n  provide: ROUTER_IS_PROVIDED,\n  useValue: true\n} : []];\n/**\r\n * @description\r\n *\r\n * Adds directives and providers for in-app navigation among views defined in an application.\r\n * Use the Angular `Router` service to declaratively specify application states and manage state\r\n * transitions.\r\n *\r\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\r\n * However, only one `Router` service can be active.\r\n * To ensure this, there are two ways to register routes when importing this module:\r\n *\r\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\r\n * routes, and the `Router` service itself.\r\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\r\n * routes, but does not include the `Router` service.\r\n *\r\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks) for an\r\n * overview of how the `Router` service should be used.\r\n *\r\n * @publicApi\r\n */\nlet RouterModule = /*#__PURE__*/(() => {\n  class RouterModule {\n    constructor() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        inject(ROUTER_FORROOT_GUARD, {\n          optional: true\n        });\n      }\n    }\n    /**\r\n     * Creates and configures a module with all the router providers and directives.\r\n     * Optionally sets up an application listener to perform an initial navigation.\r\n     *\r\n     * When registering the NgModule at the root, import as follows:\r\n     *\r\n     * ```ts\r\n     * @NgModule({\r\n     *   imports: [RouterModule.forRoot(ROUTES)]\r\n     * })\r\n     * class MyNgModule {}\r\n     * ```\r\n     *\r\n     * @param routes An array of `Route` objects that define the navigation paths for the application.\r\n     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\r\n     * @return The new `NgModule`.\r\n     *\r\n     */\n    static forRoot(routes, config) {\n      return {\n        ngModule: RouterModule,\n        providers: [ROUTER_PROVIDERS, typeof ngDevMode === 'undefined' || ngDevMode ? config?.enableTracing ? withDebugTracing().ɵproviders : [] : [], {\n          provide: ROUTES,\n          multi: true,\n          useValue: routes\n        }, typeof ngDevMode === 'undefined' || ngDevMode ? {\n          provide: ROUTER_FORROOT_GUARD,\n          useFactory: provideForRootGuard,\n          deps: [[Router, new Optional(), new SkipSelf()]]\n        } : [], config?.errorHandler ? {\n          provide: NAVIGATION_ERROR_HANDLER,\n          useValue: config.errorHandler\n        } : [], {\n          provide: ROUTER_CONFIGURATION,\n          useValue: config ? config : {}\n        }, config?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config?.preloadingStrategy ? withPreloading(config.preloadingStrategy).ɵproviders : [], config?.initialNavigation ? provideInitialNavigation(config) : [], config?.bindToComponentInputs ? withComponentInputBinding().ɵproviders : [], config?.enableViewTransitions ? withViewTransitions().ɵproviders : [], provideRouterInitializer()]\n      };\n    }\n    /**\r\n     * Creates a module with all the router directives and a provider registering routes,\r\n     * without creating a new Router service.\r\n     * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\r\n     *\r\n     * ```ts\r\n     * @NgModule({\r\n     *   imports: [RouterModule.forChild(ROUTES)]\r\n     * })\r\n     * class MyNgModule {}\r\n     * ```\r\n     *\r\n     * @param routes An array of `Route` objects that define the navigation paths for the submodule.\r\n     * @return The new NgModule.\r\n     *\r\n     */\n    static forChild(routes) {\n      return {\n        ngModule: RouterModule,\n        providers: [{\n          provide: ROUTES,\n          multi: true,\n          useValue: routes\n        }]\n      };\n    }\n    static ɵfac = function RouterModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: RouterModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return RouterModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * For internal use by `RouterModule` only. Note that this differs from `withInMemoryRouterScroller`\r\n * because it reads from the `ExtraOptions` which should not be used in the standalone world.\r\n */\nfunction provideRouterScroller() {\n  return {\n    provide: ROUTER_SCROLLER,\n    useFactory: () => {\n      const viewportScroller = inject(ViewportScroller);\n      const zone = inject(NgZone);\n      const config = inject(ROUTER_CONFIGURATION);\n      const transitions = inject(NavigationTransitions);\n      const urlSerializer = inject(UrlSerializer);\n      if (config.scrollOffset) {\n        viewportScroller.setOffset(config.scrollOffset);\n      }\n      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config);\n    }\n  };\n}\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` should\n// provide hash location directly via `{provide: LocationStrategy, useClass: HashLocationStrategy}`.\nfunction provideHashLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: HashLocationStrategy\n  };\n}\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` does not\n// need this at all because `PathLocationStrategy` is the default factory for `LocationStrategy`.\nfunction providePathLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: PathLocationStrategy\n  };\n}\nfunction provideForRootGuard(router) {\n  if (router) {\n    throw new _RuntimeError(4007 /* RuntimeErrorCode.FOR_ROOT_CALLED_TWICE */, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector.` + ` Lazy loaded modules should use RouterModule.forChild() instead.`);\n  }\n  return 'guarded';\n}\n// Note: For internal use only with `RouterModule`. Standalone router setup with `provideRouter`\n// users call `withXInitialNavigation` directly.\nfunction provideInitialNavigation(config) {\n  return [config.initialNavigation === 'disabled' ? withDisabledInitialNavigation().ɵproviders : [], config.initialNavigation === 'enabledBlocking' ? withEnabledBlockingInitialNavigation().ɵproviders : []];\n}\n// TODO(atscott): This should not be in the public API\n/**\r\n * A DI token for the router initializer that\r\n * is called after the app is bootstrapped.\r\n *\r\n * @publicApi\r\n */\nconst ROUTER_INITIALIZER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Router Initializer' : '');\nfunction provideRouterInitializer() {\n  return [\n  // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just\n  // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.\n  {\n    provide: ROUTER_INITIALIZER,\n    useFactory: getBootstrapListener\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useExisting: ROUTER_INITIALIZER\n  }];\n}\nexport { NoPreloading, PreloadAllModules, PreloadingStrategy, ROUTER_INITIALIZER, ROUTER_PROVIDERS, RouterLink, RouterLinkActive, RouterModule, RouterPreloader, provideRouter, provideRoutes, withComponentInputBinding, withDebugTracing, withDisabledInitialNavigation, withEnabledBlockingInitialNavigation, withHashLocation, withInMemoryScrolling, withNavigationErrorHandler, withPreloading, withRouterConfig, withViewTransitions };\n//# sourceMappingURL=router_module.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}