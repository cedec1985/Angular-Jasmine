{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/cedri/OneDrive/Documents/Typescript-Jasmine/src/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v20.2.1\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { NgModule, Injectable, signal, Component, ViewChild } from '@angular/core';\nimport { TestBed } from '@angular/core/testing';\nimport { ROUTES, ROUTER_CONFIGURATION, RouterOutlet, Router, afterNextNavigation } from './router2.mjs';\nexport { ɵEmptyOutletComponent as ɵɵEmptyOutletComponent } from './router2.mjs';\nimport { RouterModule, ROUTER_PROVIDERS, withPreloading, NoPreloading } from './router_module.mjs';\nexport { RouterLink as ɵɵRouterLink, RouterLinkActive as ɵɵRouterLinkActive } from './router_module.mjs';\nimport { provideLocationMocks } from '@angular/common/testing';\nimport '@angular/common';\nimport 'rxjs';\nimport 'rxjs/operators';\nimport '@angular/platform-browser';\n\n/**\n * @description\n *\n * Sets up the router to be used for testing.\n *\n * The modules sets up the router to be used for testing.\n * It provides spy implementations of `Location` and `LocationStrategy`.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * beforeEach(() => {\n *   TestBed.configureTestingModule({\n *     imports: [\n *       RouterModule.forRoot(\n *         [{path: '', component: BlankCmp}, {path: 'simple', component: SimpleCmp}]\n *       )\n *     ]\n *   });\n * });\n * ```\n *\n * @publicApi\n * @deprecated Use `provideRouter` or `RouterModule`/`RouterModule.forRoot` instead.\n * This module was previously used to provide a helpful collection of test fakes,\n * most notably those for `Location` and `LocationStrategy`.  These are generally not\n * required anymore, as `MockPlatformLocation` is provided in `TestBed` by default.\n * However, you can use them directly with `provideLocationMocks`.\n */\nlet RouterTestingModule = /*#__PURE__*/(() => {\n  class RouterTestingModule {\n    static withRoutes(routes, config) {\n      return {\n        ngModule: RouterTestingModule,\n        providers: [{\n          provide: ROUTES,\n          multi: true,\n          useValue: routes\n        }, {\n          provide: ROUTER_CONFIGURATION,\n          useValue: config ? config : {}\n        }]\n      };\n    }\n    static ɵfac = function RouterTestingModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterTestingModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: RouterTestingModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [ROUTER_PROVIDERS, provideLocationMocks(), withPreloading(NoPreloading).ɵproviders, {\n        provide: ROUTES,\n        multi: true,\n        useValue: []\n      }],\n      imports: [RouterModule]\n    });\n  }\n  return RouterTestingModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RootFixtureService = /*#__PURE__*/(() => {\n  class RootFixtureService {\n    fixture;\n    harness;\n    createHarness() {\n      if (this.harness) {\n        throw new Error('Only one harness should be created per test.');\n      }\n      this.harness = new RouterTestingHarness(this.getRootFixture());\n      return this.harness;\n    }\n    getRootFixture() {\n      if (this.fixture !== undefined) {\n        return this.fixture;\n      }\n      this.fixture = TestBed.createComponent(RootCmp);\n      this.fixture.detectChanges();\n      return this.fixture;\n    }\n    static ɵfac = function RootFixtureService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RootFixtureService)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RootFixtureService,\n      factory: RootFixtureService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return RootFixtureService;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RootCmp = /*#__PURE__*/(() => {\n  class RootCmp {\n    outlet;\n    routerOutletData = signal(undefined, ...(ngDevMode ? [{\n      debugName: \"routerOutletData\"\n    }] : []));\n    static ɵfac = function RootCmp_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RootCmp)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: RootCmp,\n      selectors: [[\"ng-component\"]],\n      viewQuery: function RootCmp_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(RouterOutlet, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.outlet = _t.first);\n        }\n      },\n      decls: 1,\n      vars: 1,\n      consts: [[3, \"routerOutletData\"]],\n      template: function RootCmp_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"router-outlet\", 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"routerOutletData\", ctx.routerOutletData());\n        }\n      },\n      dependencies: [RouterOutlet],\n      encapsulation: 2\n    });\n  }\n  return RootCmp;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A testing harness for the `Router` to reduce the boilerplate needed to test routes and routed\n * components.\n *\n * @publicApi\n */\nclass RouterTestingHarness {\n  /**\n   * Creates a `RouterTestingHarness` instance.\n   *\n   * The `RouterTestingHarness` also creates its own root component with a `RouterOutlet` for the\n   * purposes of rendering route components.\n   *\n   * Throws an error if an instance has already been created.\n   * Use of this harness also requires `destroyAfterEach: true` in the `ModuleTeardownOptions`\n   *\n   * @param initialUrl The target of navigation to trigger before returning the harness.\n   */\n  static create(initialUrl) {\n    return _asyncToGenerator(function* () {\n      const harness = TestBed.inject(RootFixtureService).createHarness();\n      if (initialUrl !== undefined) {\n        yield harness.navigateByUrl(initialUrl);\n      }\n      return harness;\n    })();\n  }\n  /**\n   * Fixture of the root component of the RouterTestingHarness\n   */\n  fixture;\n  /** @internal */\n  constructor(fixture) {\n    this.fixture = fixture;\n  }\n  /** Instructs the root fixture to run change detection. */\n  detectChanges() {\n    this.fixture.detectChanges();\n  }\n  /** The `DebugElement` of the `RouterOutlet` component. `null` if the outlet is not activated. */\n  get routeDebugElement() {\n    const outlet = this.fixture.componentInstance.outlet;\n    if (!outlet || !outlet.isActivated) {\n      return null;\n    }\n    return this.fixture.debugElement.query(v => v.componentInstance === outlet.component);\n  }\n  /** The native element of the `RouterOutlet` component. `null` if the outlet is not activated. */\n  get routeNativeElement() {\n    return this.routeDebugElement?.nativeElement ?? null;\n  }\n  navigateByUrl(url, requiredRoutedComponentType) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const router = TestBed.inject(Router);\n      let resolveFn;\n      const redirectTrackingPromise = new Promise(resolve => {\n        resolveFn = resolve;\n      });\n      afterNextNavigation(TestBed.inject(Router), resolveFn);\n      yield router.navigateByUrl(url);\n      yield redirectTrackingPromise;\n      _this.fixture.detectChanges();\n      const outlet = _this.fixture.componentInstance.outlet;\n      // The outlet might not be activated if the user is testing a navigation for a guard that\n      // rejects\n      if (outlet && outlet.isActivated && outlet.activatedRoute.component) {\n        const activatedComponent = outlet.component;\n        if (requiredRoutedComponentType !== undefined && !(activatedComponent instanceof requiredRoutedComponentType)) {\n          throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but got ${activatedComponent.constructor.name}`);\n        }\n        return activatedComponent;\n      } else {\n        if (requiredRoutedComponentType !== undefined) {\n          throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but the navigation did not activate any component.`);\n        }\n        return null;\n      }\n    })();\n  }\n}\nexport { RouterTestingHarness, RouterTestingModule, RouterOutlet as ɵɵRouterOutlet };\n//# sourceMappingURL=testing.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}