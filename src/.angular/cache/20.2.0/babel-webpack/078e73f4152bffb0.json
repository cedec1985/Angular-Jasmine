{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, computed, effect, untracked, inject, Injector, isDevMode, makeEnvironmentProviders, provideEnvironmentInitializer, NgModule, Optional } from '@angular/core';\nimport { BehaviorSubject, Observable, Subject, queueScheduler } from 'rxjs';\nimport { observeOn, withLatestFrom, scan, pluck, map, distinctUntilChanged } from 'rxjs/operators';\nimport { toSignal } from '@angular/core/rxjs-interop';\nconst REGISTERED_ACTION_TYPES = {};\nfunction resetRegisteredActionTypes() {\n  for (const key of Object.keys(REGISTERED_ACTION_TYPES)) {\n    delete REGISTERED_ACTION_TYPES[key];\n  }\n}\n\n/**\r\n * @description\r\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\r\n *\r\n * Action creators reduce the explicitness of class-based action creators.\r\n *\r\n * @param type Describes the action that will be dispatched\r\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\r\n *\r\n * @usageNotes\r\n *\r\n * **Declaring an action creator**\r\n *\r\n * Without additional metadata:\r\n * ```ts\r\n * export const increment = createAction('[Counter] Increment');\r\n * ```\r\n * With additional metadata:\r\n * ```ts\r\n * export const loginSuccess = createAction(\r\n *   '[Auth/API] Login Success',\r\n *   props<{ user: User }>()\r\n * );\r\n * ```\r\n * With a function:\r\n * ```ts\r\n * export const loginSuccess = createAction(\r\n *   '[Auth/API] Login Success',\r\n *   (response: Response) => response.user\r\n * );\r\n * ```\r\n *\r\n * **Dispatching an action**\r\n *\r\n * Without additional metadata:\r\n * ```ts\r\n * store.dispatch(increment());\r\n * ```\r\n * With additional metadata:\r\n * ```ts\r\n * store.dispatch(loginSuccess({ user: newUser }));\r\n * ```\r\n *\r\n * **Referencing an action in a reducer**\r\n *\r\n * Using a switch statement:\r\n * ```ts\r\n * switch (action.type) {\r\n *   // ...\r\n *   case AuthApiActions.loginSuccess.type: {\r\n *     return {\r\n *       ...state,\r\n *       user: action.user\r\n *     };\r\n *   }\r\n * }\r\n * ```\r\n * Using a reducer creator:\r\n * ```ts\r\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\r\n * ```\r\n *\r\n *  **Referencing an action in an effect**\r\n * ```ts\r\n * effectName$ = createEffect(\r\n *   () => this.actions$.pipe(\r\n *     ofType(AuthApiActions.loginSuccess),\r\n *     // ...\r\n *   )\r\n * );\r\n * ```\r\n */\nfunction createAction(type, config) {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n  if (typeof config === 'function') {\n    return defineType(type, (...args) => ({\n      ...config(...args),\n      type\n    }));\n  }\n  const as = config ? config._as : 'empty';\n  switch (as) {\n    case 'empty':\n      return defineType(type, () => ({\n        type\n      }));\n    case 'props':\n      return defineType(type, props => ({\n        ...props,\n        type\n      }));\n    default:\n      throw new Error('Unexpected config.');\n  }\n}\nfunction props() {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return {\n    _as: 'props',\n    _p: undefined\n  };\n}\nfunction union(creators) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return undefined;\n}\nfunction defineType(type, creator) {\n  return Object.defineProperty(creator, 'type', {\n    value: type,\n    writable: false\n  });\n}\nfunction capitalize(text) {\n  return text.charAt(0).toUpperCase() + text.substring(1);\n}\nfunction uncapitalize(text) {\n  return text.charAt(0).toLowerCase() + text.substring(1);\n}\nfunction assertDefined(value, name) {\n  if (value === null || value === undefined) {\n    throw new Error(`${name} must be defined.`);\n  }\n}\n\n/**\r\n * @description\r\n * A function that creates a group of action creators with the same source.\r\n *\r\n * @param config An object that contains a source and dictionary of events.\r\n * An event is a key-value pair of an event name and event props.\r\n * @returns A dictionary of action creators.\r\n * The name of each action creator is created by camel casing the event name.\r\n * The type of each action is created using the \"[Source] Event Name\" pattern.\r\n *\r\n * @usageNotes\r\n *\r\n * ```ts\r\n * const authApiActions = createActionGroup({\r\n *   source: 'Auth API',\r\n *   events: {\r\n *     // defining events with payload using the `props` function\r\n *     'Login Success': props<{ userId: number; token: string }>(),\r\n *     'Login Failure': props<{ error: string }>(),\r\n *\r\n *     // defining an event without payload using the `emptyProps` function\r\n *     'Logout Success': emptyProps(),\r\n *\r\n *     // defining an event with payload using the props factory\r\n *     'Logout Failure': (error: Error) => ({ error }),\r\n *   },\r\n * });\r\n *\r\n * // action type: \"[Auth API] Login Success\"\r\n * authApiActions.loginSuccess({ userId: 10, token: 'ngrx' });\r\n *\r\n * // action type: \"[Auth API] Login Failure\"\r\n * authApiActions.loginFailure({ error: 'Login Failure!' });\r\n *\r\n * // action type: \"[Auth API] Logout Success\"\r\n * authApiActions.logoutSuccess();\r\n *\r\n * // action type: \"[Auth API] Logout Failure\";\r\n * authApiActions.logoutFailure(new Error('Logout Failure!'));\r\n * ```\r\n */\nfunction createActionGroup(config) {\n  const {\n    source,\n    events\n  } = config;\n  return Object.keys(events).reduce((actionGroup, eventName) => ({\n    ...actionGroup,\n    [toActionName(eventName)]: createAction(toActionType(source, eventName), events[eventName])\n  }), {});\n}\nfunction emptyProps() {\n  return props();\n}\nfunction toActionName(eventName) {\n  return eventName.trim().split(' ').map((word, i) => i === 0 ? uncapitalize(word) : capitalize(word)).join('');\n}\nfunction toActionType(source, eventName) {\n  return `[${source}] ${eventName}`;\n}\nconst INIT = '@ngrx/store/init';\nlet ActionsSubject = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class ActionsSubject extends BehaviorSubject {\n    constructor() {\n      super({\n        type: INIT\n      });\n    }\n    next(action) {\n      if (typeof action === 'function') {\n        throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n      } else if (typeof action === 'undefined') {\n        throw new TypeError(`Actions must be objects`);\n      } else if (typeof action.type === 'undefined') {\n        throw new TypeError(`Actions must have a type property`);\n      }\n      super.next(action);\n    }\n    complete() {\n      /* noop */\n    }\n    ngOnDestroy() {\n      super.complete();\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock = () => (this.ɵfac = function ActionsSubject_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ActionsSubject)();\n    }, this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ActionsSubject,\n      factory: ActionsSubject.ɵfac\n    }));\n  }\n  _staticBlock();\n  return ActionsSubject;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\nconst _ROOT_STORE_GUARD = new InjectionToken('@ngrx/store Internal Root Guard');\nconst _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\nconst INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nconst REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\nconst _REDUCER_FACTORY = new InjectionToken('@ngrx/store Internal Reducer Factory Provider');\nconst INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\nconst _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\nconst STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\nconst _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\nconst _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\nconst _FEATURE_CONFIGS = new InjectionToken('@ngrx/store Internal Feature Configs');\nconst _STORE_FEATURES = new InjectionToken('@ngrx/store Internal Store Features');\nconst _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\nconst FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\n/**\r\n * User-defined meta reducers from StoreModule.forRoot()\r\n */\nconst USER_PROVIDED_META_REDUCERS = new InjectionToken('@ngrx/store User Provided Meta Reducers');\n/**\r\n * Meta reducers defined either internally by @ngrx/store or by library authors\r\n */\nconst META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\n/**\r\n * Concats the user provided meta reducers and the meta reducers provided on the multi\r\n * injection token\r\n */\nconst _RESOLVED_META_REDUCERS = new InjectionToken('@ngrx/store Internal Resolved Meta Reducers');\n/**\r\n * Runtime checks defined by the user via an InjectionToken\r\n * Defaults to `_USER_RUNTIME_CHECKS`\r\n */\nconst USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store User Runtime Checks Config');\n/**\r\n * Runtime checks defined by the user via forRoot()\r\n */\nconst _USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal User Runtime Checks Config');\n/**\r\n * Runtime checks currently in use\r\n */\nconst ACTIVE_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal Runtime Checks');\nconst _ACTION_TYPE_UNIQUENESS_CHECK = new InjectionToken('@ngrx/store Check if Action types are unique');\n/**\r\n * InjectionToken that registers the global Store.\r\n * Mainly used to provide a hook that can be injected\r\n * to ensure the root state is loaded before something\r\n * that depends on it.\r\n */\nconst ROOT_STORE_PROVIDER = new InjectionToken('@ngrx/store Root Store Provider');\n/**\r\n * InjectionToken that registers feature states.\r\n * Mainly used to provide a hook that can be injected\r\n * to ensure feature state is loaded before something\r\n * that depends on it.\r\n */\nconst FEATURE_STATE_PROVIDER = new InjectionToken('@ngrx/store Feature State Provider');\n\n/**\r\n * @description\r\n * Combines reducers for individual features into a single reducer.\r\n *\r\n * You can use this function to delegate handling of state transitions to multiple reducers, each acting on their\r\n * own sub-state within the root state.\r\n *\r\n * @param reducers An object mapping keys of the root state to their corresponding feature reducer.\r\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\r\n * @returns A reducer function.\r\n *\r\n * @usageNotes\r\n *\r\n * **Example combining two feature reducers into one \"root\" reducer**\r\n *\r\n * ```ts\r\n * export const reducer = combineReducers({\r\n *   featureA: featureAReducer,\r\n *   featureB: featureBReducer\r\n * });\r\n * ```\r\n *\r\n * You can also override the initial states of the sub-features:\r\n * ```ts\r\n * export const reducer = combineReducers({\r\n *   featureA: featureAReducer,\r\n *   featureB: featureBReducer\r\n * }, {\r\n *   featureA: { counterA: 13 },\r\n *   featureB: { counterB: 37 }\r\n * });\r\n * ```\r\n */\nfunction combineReducers(reducers, initialState = {}) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  return function combination(state, action) {\n    state = state === undefined ? initialState : state;\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\nfunction omit(object, keyToRemove) {\n  return Object.keys(object).filter(key => key !== keyToRemove).reduce((result, key) => Object.assign(result, {\n    [key]: object[key]\n  }), {});\n}\nfunction compose(...functions) {\n  return function (arg) {\n    if (functions.length === 0) {\n      return arg;\n    }\n    const last = functions[functions.length - 1];\n    const rest = functions.slice(0, -1);\n    return rest.reduceRight((composed, fn) => fn(composed), last(arg));\n  };\n}\nfunction createReducerFactory(reducerFactory, metaReducers) {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    reducerFactory = compose.apply(null, [...metaReducers, reducerFactory]);\n  }\n  return (reducers, initialState) => {\n    const reducer = reducerFactory(reducers);\n    return (state, action) => {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\nfunction createFeatureReducerFactory(metaReducers) {\n  const reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0 ? compose(...metaReducers) : r => r;\n  return (reducer, initialState) => {\n    reducer = reducerFactory(reducer);\n    return (state, action) => {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\nclass ReducerObservable extends Observable {}\nclass ReducerManagerDispatcher extends ActionsSubject {}\nconst UPDATE = '@ngrx/store/update-reducers';\nlet ReducerManager = /*#__PURE__*/(() => {\n  var _staticBlock2;\n  class ReducerManager extends BehaviorSubject {\n    get currentReducers() {\n      return this.reducers;\n    }\n    constructor(dispatcher, initialState, reducers, reducerFactory) {\n      super(reducerFactory(reducers, initialState));\n      this.dispatcher = dispatcher;\n      this.initialState = initialState;\n      this.reducers = reducers;\n      this.reducerFactory = reducerFactory;\n    }\n    addFeature(feature) {\n      this.addFeatures([feature]);\n    }\n    addFeatures(features) {\n      const reducers = features.reduce((reducerDict, {\n        reducers,\n        reducerFactory,\n        metaReducers,\n        initialState,\n        key\n      }) => {\n        const reducer = typeof reducers === 'function' ? createFeatureReducerFactory(metaReducers)(reducers, initialState) : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n        reducerDict[key] = reducer;\n        return reducerDict;\n      }, {});\n      this.addReducers(reducers);\n    }\n    removeFeature(feature) {\n      this.removeFeatures([feature]);\n    }\n    removeFeatures(features) {\n      this.removeReducers(features.map(p => p.key));\n    }\n    addReducer(key, reducer) {\n      this.addReducers({\n        [key]: reducer\n      });\n    }\n    addReducers(reducers) {\n      this.reducers = {\n        ...this.reducers,\n        ...reducers\n      };\n      this.updateReducers(Object.keys(reducers));\n    }\n    removeReducer(featureKey) {\n      this.removeReducers([featureKey]);\n    }\n    removeReducers(featureKeys) {\n      featureKeys.forEach(key => {\n        this.reducers = omit(this.reducers, key) /*TODO(#823)*/;\n      });\n      this.updateReducers(featureKeys);\n    }\n    updateReducers(featureKeys) {\n      this.next(this.reducerFactory(this.reducers, this.initialState));\n      this.dispatcher.next({\n        type: UPDATE,\n        features: featureKeys\n      });\n    }\n    ngOnDestroy() {\n      this.complete();\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock2 = () => (this.ɵfac = function ReducerManager_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ReducerManager)(i0.ɵɵinject(ReducerManagerDispatcher), i0.ɵɵinject(INITIAL_STATE), i0.ɵɵinject(INITIAL_REDUCERS), i0.ɵɵinject(REDUCER_FACTORY));\n    }, this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ReducerManager,\n      factory: ReducerManager.ɵfac\n    }));\n  }\n  _staticBlock2();\n  return ReducerManager;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst REDUCER_MANAGER_PROVIDERS = [ReducerManager, {\n  provide: ReducerObservable,\n  useExisting: ReducerManager\n}, {\n  provide: ReducerManagerDispatcher,\n  useExisting: ActionsSubject\n}];\nlet ScannedActionsSubject = /*#__PURE__*/(() => {\n  var _staticBlock3;\n  class ScannedActionsSubject extends Subject {\n    ngOnDestroy() {\n      this.complete();\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock3 = () => (this.ɵfac = /* @__PURE__ */(() => {\n      let ɵScannedActionsSubject_BaseFactory;\n      return function ScannedActionsSubject_Factory(__ngFactoryType__) {\n        return (ɵScannedActionsSubject_BaseFactory || (ɵScannedActionsSubject_BaseFactory = i0.ɵɵgetInheritedFactory(ScannedActionsSubject)))(__ngFactoryType__ || ScannedActionsSubject);\n      };\n    })(), this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ScannedActionsSubject,\n      factory: ScannedActionsSubject.ɵfac\n    }));\n  }\n  _staticBlock3();\n  return ScannedActionsSubject;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SCANNED_ACTIONS_SUBJECT_PROVIDERS = [ScannedActionsSubject];\nclass StateObservable extends Observable {}\nlet State = /*#__PURE__*/(() => {\n  var _staticBlock4;\n  class State extends BehaviorSubject {\n    constructor(actions$, reducer$, scannedActions, initialState) {\n      super(initialState);\n      const actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n      const withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n      const seed = {\n        state: initialState\n      };\n      const stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n      this.stateSubscription = stateAndAction$.subscribe(({\n        state,\n        action\n      }) => {\n        this.next(state);\n        scannedActions.next(action);\n      });\n      this.state = toSignal(this, {\n        manualCleanup: true,\n        requireSync: true\n      });\n    }\n    ngOnDestroy() {\n      this.stateSubscription.unsubscribe();\n      this.complete();\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock4 = () => (this.INIT = INIT, this.ɵfac = function State_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || State)(i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerObservable), i0.ɵɵinject(ScannedActionsSubject), i0.ɵɵinject(INITIAL_STATE));\n    }, this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: State,\n      factory: State.ɵfac\n    }));\n  }\n  _staticBlock4();\n  return State;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction reduceState(stateActionPair = {\n  state: undefined\n}, [action, reducer]) {\n  const {\n    state\n  } = stateActionPair;\n  return {\n    state: reducer(state, action),\n    action\n  };\n}\nconst STATE_PROVIDERS = [State, {\n  provide: StateObservable,\n  useExisting: State\n}];\n\n// disabled because we have lowercase generics for `select`\n/**\r\n * @description\r\n * Store is an injectable service that provides reactive state management and a public API for dispatching actions.\r\n *\r\n * @usageNotes\r\n *\r\n * In a component:\r\n *\r\n * ```ts\r\n * import { Component, inject } from '@angular/core';\r\n * import { Store } from '@ngrx/store';\r\n *\r\n * @Component({\r\n *  selector: 'app-my-component',\r\n *  template: `\r\n *    <div>{{ count() }}</div>\r\n *    <button (click)=\"increment()\">Increment</button>\r\n *  `\r\n * })\r\n * export class MyComponent {\r\n *   private store = inject(Store);\r\n *\r\n *   count = this.store.selectSignal(state => state.count);\r\n *\r\n *   increment() {\r\n *     this.store.dispatch({ type: 'INCREMENT' });\r\n *   }\r\n * }\r\n * ```\r\n *\r\n */\nlet Store = /*#__PURE__*/(() => {\n  var _staticBlock5;\n  class Store extends Observable {\n    constructor(state$, actionsObserver, reducerManager, injector) {\n      super();\n      this.actionsObserver = actionsObserver;\n      this.reducerManager = reducerManager;\n      this.injector = injector;\n      this.source = state$;\n      this.state = state$.state;\n    }\n    /**\r\n     * @deprecated Selectors with props are deprecated, for more info see {@link https://github.com/ngrx/platform/issues/2980 Github Issue}\r\n     */\n    select(pathOrMapFn, ...paths) {\n      return select.call(null, pathOrMapFn, ...paths)(this);\n    }\n    /**\r\n     * Returns a signal of the provided selector.\r\n     *\r\n     * @param selector selector function\r\n     * @param options select signal options\r\n     * @returns Signal of the state selected by the provided selector\r\n     * @usageNotes\r\n     *\r\n     * ```ts\r\n     * const count = this.store.selectSignal(state => state.count);\r\n     * ```\r\n     *\r\n     * Or with a selector created by @ngrx/store!createSelector:function\r\n     *\r\n     * ```ts\r\n     * const selectCount = createSelector(\r\n     *  (state: State) => state.count,\r\n     * );\r\n     *\r\n     * const count = this.store.selectSignal(selectCount);\r\n     * ```\r\n     */\n    selectSignal(selector, options) {\n      return computed(() => selector(this.state()), options);\n    }\n    lift(operator) {\n      const store = new Store(this, this.actionsObserver, this.reducerManager);\n      store.operator = operator;\n      return store;\n    }\n    dispatch(actionOrDispatchFn, config) {\n      if (typeof actionOrDispatchFn === 'function') {\n        return this.processDispatchFn(actionOrDispatchFn, config);\n      }\n      this.actionsObserver.next(actionOrDispatchFn);\n    }\n    next(action) {\n      this.actionsObserver.next(action);\n    }\n    error(err) {\n      this.actionsObserver.error(err);\n    }\n    complete() {\n      this.actionsObserver.complete();\n    }\n    addReducer(key, reducer) {\n      this.reducerManager.addReducer(key, reducer);\n    }\n    removeReducer(key) {\n      this.reducerManager.removeReducer(key);\n    }\n    processDispatchFn(dispatchFn, config) {\n      assertDefined(this.injector, 'Store Injector');\n      const effectInjector = config?.injector ?? getCallerInjector() ?? this.injector;\n      return effect(() => {\n        const action = dispatchFn();\n        untracked(() => this.dispatch(action));\n      }, {\n        injector: effectInjector\n      });\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock5 = () => (this.ɵfac = function Store_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Store)(i0.ɵɵinject(StateObservable), i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerManager), i0.ɵɵinject(i0.Injector));\n    }, this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Store,\n      factory: Store.ɵfac\n    }));\n  }\n  _staticBlock5();\n  return Store;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst STORE_PROVIDERS = [Store];\nfunction select(pathOrMapFn, propsOrPath, ...paths) {\n  return function selectOperator(source$) {\n    let mapped$;\n    if (typeof pathOrMapFn === 'string') {\n      const pathSlices = [propsOrPath, ...paths].filter(Boolean);\n      mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n    } else if (typeof pathOrMapFn === 'function') {\n      mapped$ = source$.pipe(map(source => pathOrMapFn(source, propsOrPath)));\n    } else {\n      throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator,` + ` expected 'string' or 'function'`);\n    }\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch (_) {\n    return undefined;\n  }\n}\nconst RUNTIME_CHECK_URL = 'https://ngrx.io/guide/store/configuration/runtime-checks';\nfunction isUndefined(target) {\n  return target === undefined;\n}\nfunction isNull(target) {\n  return target === null;\n}\nfunction isArray(target) {\n  return Array.isArray(target);\n}\nfunction isString(target) {\n  return typeof target === 'string';\n}\nfunction isBoolean(target) {\n  return typeof target === 'boolean';\n}\nfunction isNumber(target) {\n  return typeof target === 'number';\n}\nfunction isObjectLike(target) {\n  return typeof target === 'object' && target !== null;\n}\nfunction isObject(target) {\n  return isObjectLike(target) && !isArray(target);\n}\nfunction isPlainObject(target) {\n  if (!isObject(target)) {\n    return false;\n  }\n  const targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\nfunction isFunction(target) {\n  return typeof target === 'function';\n}\nfunction isComponent(target) {\n  return isFunction(target) && target.hasOwnProperty('ɵcmp');\n}\nfunction hasOwnProperty(target, propertyName) {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\nlet _ngrxMockEnvironment = false;\nfunction setNgrxMockEnvironment(value) {\n  _ngrxMockEnvironment = value;\n}\nfunction isNgrxMockEnvironment() {\n  return _ngrxMockEnvironment;\n}\nfunction isEqualCheck(a, b) {\n  return a === b;\n}\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n  for (let i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction resultMemoize(projectionFn, isResultEqual) {\n  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\nfunction defaultMemoize(projectionFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck) {\n  let lastArguments = null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let lastResult = null;\n  let overrideResult;\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n  function setResult(result = undefined) {\n    overrideResult = {\n      result\n    };\n  }\n  function clearResult() {\n    overrideResult = undefined;\n  }\n  /* eslint-disable prefer-rest-params, prefer-spread */\n  // disabled because of the use of `arguments`\n  function memoized() {\n    if (overrideResult !== undefined) {\n      return overrideResult.result;\n    }\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, arguments);\n      lastArguments = arguments;\n      return lastResult;\n    }\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n    const newResult = projectionFn.apply(null, arguments);\n    lastArguments = arguments;\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n    lastResult = newResult;\n    return newResult;\n  }\n  return {\n    memoized,\n    reset,\n    setResult,\n    clearResult\n  };\n}\nfunction createSelector(...input) {\n  return createSelectorFactory(defaultMemoize)(...input);\n}\nfunction defaultStateFn(state, selectors, props, memoizedProjector) {\n  if (props === undefined) {\n    const args = selectors.map(fn => fn(state));\n    return memoizedProjector.memoized.apply(null, args);\n  }\n  const args = selectors.map(fn => fn(state, props));\n  return memoizedProjector.memoized.apply(null, [...args, props]);\n}\n/**\r\n *\r\n * @param memoize The function used to memoize selectors\r\n * @param options Config Object that may include a `stateFn` function defining how to return the selector's value, given the entire `Store`'s state, parent `Selector`s, `Props`, and a `MemoizedProjection`\r\n *\r\n * @usageNotes\r\n *\r\n * **Creating a Selector Factory Where Array Order Does Not Matter**\r\n *\r\n * ```ts\r\n * function removeMatch(arr: string[], target: string): string[] {\r\n *   const matchIndex = arr.indexOf(target);\r\n *   return [...arr.slice(0, matchIndex), ...arr.slice(matchIndex + 1)];\r\n * }\r\n *\r\n * function orderDoesNotMatterComparer(a: any, b: any): boolean {\r\n *   if (!Array.isArray(a) || !Array.isArray(b)) {\r\n *     return a === b;\r\n *   }\r\n *   if (a.length !== b.length) {\r\n *     return false;\r\n *   }\r\n *   let tempB = [...b];\r\n *   function reduceToDetermineIfArraysContainSameContents(\r\n *     previousCallResult: boolean,\r\n *     arrayMember: any\r\n *   ): boolean {\r\n *     if (previousCallResult === false) {\r\n *       return false;\r\n *     }\r\n *     if (tempB.includes(arrayMember)) {\r\n *       tempB = removeMatch(tempB, arrayMember);\r\n *       return true;\r\n *     }\r\n *     return false;\r\n *   }\r\n *   return a.reduce(reduceToDetermineIfArraysContainSameContents, true);\r\n * }\r\n *\r\n * export const createOrderDoesNotMatterSelector = createSelectorFactory(\r\n *   (projectionFun) => defaultMemoize(\r\n *     projectionFun,\r\n *     orderDoesNotMatterComparer,\r\n *     orderDoesNotMatterComparer\r\n *   )\r\n * );\r\n * ```\r\n *\r\n * **Creating an Alternative Memoization Strategy**\r\n *\r\n * ```ts\r\n * function serialize(x: any): string {\r\n *   return JSON.stringify(x);\r\n * }\r\n *\r\n * export const createFullHistorySelector = createSelectorFactory(\r\n *  (projectionFunction) => {\r\n *    const cache = {};\r\n *\r\n *    function memoized() {\r\n *      const serializedArguments = serialize(...arguments);\r\n *       if (cache[serializedArguments] != null) {\r\n *         cache[serializedArguments] = projectionFunction.apply(null, arguments);\r\n *       }\r\n *       return cache[serializedArguments];\r\n *     }\r\n *     return {\r\n *       memoized,\r\n *       reset: () => {},\r\n *       setResult: () => {},\r\n *       clearResult: () => {},\r\n *     };\r\n *   }\r\n * );\r\n * ```\r\n */\nfunction createSelectorFactory(memoize, options = {\n  stateFn: defaultStateFn\n}) {\n  return function (...input) {\n    let args = input;\n    if (Array.isArray(args[0])) {\n      const [head, ...tail] = args;\n      args = [...head, ...tail];\n    } else if (args.length === 1 && isSelectorsDictionary(args[0])) {\n      args = extractArgsFromSelectorsDictionary(args[0]);\n    }\n    const selectors = args.slice(0, args.length - 1);\n    const projector = args[args.length - 1];\n    const memoizedSelectors = selectors.filter(selector => selector.release && typeof selector.release === 'function');\n    const memoizedProjector = memoize(function (...selectors) {\n      return projector.apply(null, selectors);\n    });\n    const memoizedState = defaultMemoize(function (state, props) {\n      return options.stateFn.apply(null, [state, selectors, props, memoizedProjector]);\n    });\n    function release() {\n      memoizedState.reset();\n      memoizedProjector.reset();\n      memoizedSelectors.forEach(selector => selector.release());\n    }\n    return Object.assign(memoizedState.memoized, {\n      release,\n      projector: memoizedProjector.memoized,\n      setResult: memoizedState.setResult,\n      clearResult: memoizedState.clearResult\n    });\n  };\n}\nfunction createFeatureSelector(featureName) {\n  return createSelector(state => {\n    const featureState = state[featureName];\n    if (!isNgrxMockEnvironment() && isDevMode() && !(featureName in state)) {\n      console.warn(`@ngrx/store: The feature name \"${featureName}\" does ` + 'not exist in the state, therefore createFeatureSelector ' + 'cannot access it.  Be sure it is imported in a loaded module ' + `using StoreModule.forRoot('${featureName}', ...) or ` + `StoreModule.forFeature('${featureName}', ...).  If the default ` + 'state is intended to be undefined, as is the case with router ' + 'state, this development-only warning message can be ignored.');\n    }\n    return featureState;\n  }, featureState => featureState);\n}\nfunction isSelectorsDictionary(selectors) {\n  return !!selectors && typeof selectors === 'object' && Object.values(selectors).every(selector => typeof selector === 'function');\n}\nfunction extractArgsFromSelectorsDictionary(selectorsDictionary) {\n  const selectors = Object.values(selectorsDictionary);\n  const resultKeys = Object.keys(selectorsDictionary);\n  const projector = (...selectorResults) => resultKeys.reduce((result, key, index) => ({\n    ...result,\n    [key]: selectorResults[index]\n  }), {});\n  return [...selectors, projector];\n}\n\n/**\r\n * @description\r\n * A function that accepts a feature name and a feature reducer, and creates\r\n * a feature selector and a selector for each feature state property.\r\n * This function also provides the ability to add extra selectors to\r\n * the feature object.\r\n *\r\n * @param featureConfig An object that contains a feature name and a feature\r\n * reducer as required, and extra selectors factory as an optional argument.\r\n * @returns An object that contains a feature name, a feature reducer,\r\n * a feature selector, a selector for each feature state property, and extra\r\n * selectors.\r\n *\r\n * @usageNotes\r\n *\r\n * ```ts\r\n * interface ProductsState {\r\n *   products: Product[];\r\n *   selectedId: string | null;\r\n * }\r\n *\r\n * const initialState: ProductsState = {\r\n *   products: [],\r\n *   selectedId: null,\r\n * };\r\n *\r\n * const productsFeature = createFeature({\r\n *   name: 'products',\r\n *   reducer: createReducer(\r\n *     initialState,\r\n *     on(ProductsApiActions.loadSuccess(state, { products }) => ({\r\n *       ...state,\r\n *       products,\r\n *     }),\r\n *   ),\r\n * });\r\n *\r\n * const {\r\n *   name,\r\n *   reducer,\r\n *   // feature selector\r\n *   selectProductsState, // type: MemoizedSelector<Record<string, any>, ProductsState>\r\n *   // feature state properties selectors\r\n *   selectProducts, // type: MemoizedSelector<Record<string, any>, Product[]>\r\n *   selectSelectedId, // type: MemoizedSelector<Record<string, any>, string | null>\r\n * } = productsFeature;\r\n * ```\r\n *\r\n * **Creating Feature with Extra Selectors**\r\n *\r\n * ```ts\r\n * type CallState = 'init' | 'loading' | 'loaded' | { error: string };\r\n *\r\n * interface State extends EntityState<Product> {\r\n *   callState: CallState;\r\n * }\r\n *\r\n * const adapter = createEntityAdapter<Product>();\r\n * const initialState: State = adapter.getInitialState({\r\n *   callState: 'init',\r\n * });\r\n *\r\n * export const productsFeature = createFeature({\r\n *   name: 'products',\r\n *   reducer: createReducer(initialState),\r\n *   extraSelectors: ({ selectProductsState, selectCallState }) => ({\r\n *     ...adapter.getSelectors(selectProductsState),\r\n *     ...getCallStateSelectors(selectCallState)\r\n *   }),\r\n * });\r\n *\r\n * const {\r\n *   name,\r\n *   reducer,\r\n *   // feature selector\r\n *   selectProductsState,\r\n *   // feature state properties selectors\r\n *   selectIds,\r\n *   selectEntities,\r\n *   selectCallState,\r\n *   // selectors returned by `adapter.getSelectors`\r\n *   selectAll,\r\n *   selectTotal,\r\n *   // selectors returned by `getCallStateSelectors`\r\n *   selectIsLoading,\r\n *   selectIsLoaded,\r\n *   selectError,\r\n * } = productsFeature;\r\n * ```\r\n */\nfunction createFeature(featureConfig) {\n  const {\n    name,\n    reducer,\n    extraSelectors: extraSelectorsFactory\n  } = featureConfig;\n  const featureSelector = createFeatureSelector(name);\n  const nestedSelectors = createNestedSelectors(featureSelector, reducer);\n  const baseSelectors = {\n    [`select${capitalize(name)}State`]: featureSelector,\n    ...nestedSelectors\n  };\n  const extraSelectors = extraSelectorsFactory ? extraSelectorsFactory(baseSelectors) : {};\n  return {\n    name,\n    reducer,\n    ...baseSelectors,\n    ...extraSelectors\n  };\n}\nfunction createNestedSelectors(featureSelector, reducer) {\n  const initialState = getInitialState(reducer);\n  const nestedKeys = isPlainObject(initialState) ? Object.keys(initialState) : [];\n  return nestedKeys.reduce((nestedSelectors, nestedKey) => ({\n    ...nestedSelectors,\n    [`select${capitalize(nestedKey)}`]: createSelector(featureSelector, parentState => parentState?.[nestedKey])\n  }), {});\n}\nfunction getInitialState(reducer) {\n  return reducer(undefined, {\n    type: '@ngrx/feature/init'\n  });\n}\nfunction _createStoreReducers(reducers) {\n  return reducers instanceof InjectionToken ? inject(reducers) : reducers;\n}\nfunction _createFeatureStore(configs, featureStores) {\n  return featureStores.map((feat, index) => {\n    if (configs[index] instanceof InjectionToken) {\n      const conf = inject(configs[index]);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory ? conf.reducerFactory : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState\n      };\n    }\n    return feat;\n  });\n}\nfunction _createFeatureReducers(reducerCollection) {\n  return reducerCollection.map(reducer => {\n    return reducer instanceof InjectionToken ? inject(reducer) : reducer;\n  });\n}\nfunction _initialStateFactory(initialState) {\n  if (typeof initialState === 'function') {\n    return initialState();\n  }\n  return initialState;\n}\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\nfunction _provideForRootGuard() {\n  const store = inject(Store, {\n    optional: true,\n    skipSelf: true\n  });\n  if (store) {\n    throw new TypeError(`The root Store has been provided more than once. Feature modules should provide feature states instead.`);\n  }\n  return 'guarded';\n}\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n  return function (state, action) {\n    const act = checks.action(action) ? freeze(action) : action;\n    const nextState = reducer(state, act);\n    return checks.state() ? freeze(nextState) : nextState;\n  };\n}\nfunction freeze(target) {\n  Object.freeze(target);\n  const targetIsFunction = isFunction(target);\n  Object.getOwnPropertyNames(target).forEach(prop => {\n    // Ignore Ivy properties, ref: https://github.com/ngrx/platform/issues/2109#issuecomment-582689060\n    if (prop.startsWith('ɵ')) {\n      return;\n    }\n    if (hasOwnProperty(target, prop) && (targetIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true)) {\n      const propValue = target[prop];\n      if ((isObjectLike(propValue) || isFunction(propValue)) && !Object.isFrozen(propValue)) {\n        freeze(propValue);\n      }\n    }\n  });\n  return target;\n}\nfunction serializationCheckMetaReducer(reducer, checks) {\n  return function (state, action) {\n    if (checks.action(action)) {\n      const unserializableAction = getUnserializable(action);\n      throwIfUnserializable(unserializableAction, 'action');\n    }\n    const nextState = reducer(state, action);\n    if (checks.state()) {\n      const unserializableState = getUnserializable(nextState);\n      throwIfUnserializable(unserializableState, 'state');\n    }\n    return nextState;\n  };\n}\nfunction getUnserializable(target, path = []) {\n  // Guard against undefined and null, e.g. a reducer that returns undefined\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: ['root'],\n      value: target\n    };\n  }\n  const keys = Object.keys(target);\n  return keys.reduce((result, key) => {\n    if (result) {\n      return result;\n    }\n    const value = target[key];\n    // Ignore Ivy components\n    if (isComponent(value)) {\n      return result;\n    }\n    if (isUndefined(value) || isNull(value) || isNumber(value) || isBoolean(value) || isString(value) || isArray(value)) {\n      return false;\n    }\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [...path, key]);\n    }\n    return {\n      path: [...path, key],\n      value\n    };\n  }, false);\n}\nfunction throwIfUnserializable(unserializable, context) {\n  if (unserializable === false) {\n    return;\n  }\n  const unserializablePath = unserializable.path.join('.');\n  const error = new Error(`Detected unserializable ${context} at \"${unserializablePath}\". ${RUNTIME_CHECK_URL}#strict${context}serializability`);\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\nfunction inNgZoneAssertMetaReducer(reducer, checks) {\n  return function (state, action) {\n    if (checks.action(action) && !i0.NgZone.isInAngularZone()) {\n      throw new Error(`Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`);\n    }\n    return reducer(state, action);\n  };\n}\nfunction createActiveRuntimeChecks(runtimeChecks) {\n  if (isDevMode()) {\n    return {\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: true,\n      strictActionImmutability: true,\n      strictActionWithinNgZone: false,\n      strictActionTypeUniqueness: false,\n      ...runtimeChecks\n    };\n  }\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false,\n    strictActionWithinNgZone: false,\n    strictActionTypeUniqueness: false\n  };\n}\nfunction createSerializationCheckMetaReducer({\n  strictActionSerializability,\n  strictStateSerializability\n}) {\n  return reducer => strictActionSerializability || strictStateSerializability ? serializationCheckMetaReducer(reducer, {\n    action: action => strictActionSerializability && !ignoreNgrxAction(action),\n    state: () => strictStateSerializability\n  }) : reducer;\n}\nfunction createImmutabilityCheckMetaReducer({\n  strictActionImmutability,\n  strictStateImmutability\n}) {\n  return reducer => strictActionImmutability || strictStateImmutability ? immutabilityCheckMetaReducer(reducer, {\n    action: action => strictActionImmutability && !ignoreNgrxAction(action),\n    state: () => strictStateImmutability\n  }) : reducer;\n}\nfunction ignoreNgrxAction(action) {\n  return action.type.startsWith('@ngrx');\n}\nfunction createInNgZoneCheckMetaReducer({\n  strictActionWithinNgZone\n}) {\n  return reducer => strictActionWithinNgZone ? inNgZoneAssertMetaReducer(reducer, {\n    action: action => strictActionWithinNgZone && !ignoreNgrxAction(action)\n  }) : reducer;\n}\nfunction provideRuntimeChecks(runtimeChecks) {\n  return [{\n    provide: _USER_RUNTIME_CHECKS,\n    useValue: runtimeChecks\n  }, {\n    provide: USER_RUNTIME_CHECKS,\n    useFactory: _runtimeChecksFactory,\n    deps: [_USER_RUNTIME_CHECKS]\n  }, {\n    provide: ACTIVE_RUNTIME_CHECKS,\n    deps: [USER_RUNTIME_CHECKS],\n    useFactory: createActiveRuntimeChecks\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createImmutabilityCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createSerializationCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createInNgZoneCheckMetaReducer\n  }];\n}\nfunction checkForActionTypeUniqueness() {\n  return [{\n    provide: _ACTION_TYPE_UNIQUENESS_CHECK,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: _actionTypeUniquenessCheck\n  }];\n}\nfunction _runtimeChecksFactory(runtimeChecks) {\n  return runtimeChecks;\n}\nfunction _actionTypeUniquenessCheck(config) {\n  if (!config.strictActionTypeUniqueness) {\n    return;\n  }\n  const duplicates = Object.entries(REGISTERED_ACTION_TYPES).filter(([, registrations]) => registrations > 1).map(([type]) => type);\n  if (duplicates.length) {\n    throw new Error(`Action types are registered more than once, ${duplicates.map(type => `\"${type}\"`).join(', ')}. ${RUNTIME_CHECK_URL}#strictactiontypeuniqueness`);\n  }\n}\n\n/**\r\n * Provides additional slices of state in the Store.\r\n * These providers cannot be used at the component level.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Providing Store Features\r\n *\r\n * ```ts\r\n * const booksRoutes: Route[] = [\r\n *   {\r\n *     path: '',\r\n *     providers: [provideState('books', booksReducer)],\r\n *     children: [\r\n *       { path: '', component: BookListComponent },\r\n *       { path: ':id', component: BookDetailsComponent },\r\n *     ],\r\n *   },\r\n * ];\r\n * ```\r\n */\nfunction provideState(featureNameOrSlice, reducers, config = {}) {\n  return makeEnvironmentProviders([..._provideState(featureNameOrSlice, reducers, config), ENVIRONMENT_STATE_PROVIDER]);\n}\nfunction _provideStore(reducers = {}, config = {}) {\n  return [{\n    provide: _ROOT_STORE_GUARD,\n    useFactory: _provideForRootGuard\n  }, {\n    provide: _INITIAL_STATE,\n    useValue: config.initialState\n  }, {\n    provide: INITIAL_STATE,\n    useFactory: _initialStateFactory,\n    deps: [_INITIAL_STATE]\n  }, {\n    provide: _INITIAL_REDUCERS,\n    useValue: reducers\n  }, {\n    provide: _STORE_REDUCERS,\n    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS\n  }, {\n    provide: INITIAL_REDUCERS,\n    deps: [_INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n    useFactory: _createStoreReducers\n  }, {\n    provide: USER_PROVIDED_META_REDUCERS,\n    useValue: config.metaReducers ? config.metaReducers : []\n  }, {\n    provide: _RESOLVED_META_REDUCERS,\n    deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n    useFactory: _concatMetaReducers\n  }, {\n    provide: _REDUCER_FACTORY,\n    useValue: config.reducerFactory ? config.reducerFactory : combineReducers\n  }, {\n    provide: REDUCER_FACTORY,\n    deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n    useFactory: createReducerFactory\n  }, ACTIONS_SUBJECT_PROVIDERS, REDUCER_MANAGER_PROVIDERS, SCANNED_ACTIONS_SUBJECT_PROVIDERS, STATE_PROVIDERS, STORE_PROVIDERS, provideRuntimeChecks(config.runtimeChecks), checkForActionTypeUniqueness()];\n}\nfunction rootStoreProviderFactory() {\n  inject(ActionsSubject);\n  inject(ReducerObservable);\n  inject(ScannedActionsSubject);\n  inject(Store);\n  inject(_ROOT_STORE_GUARD, {\n    optional: true\n  });\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, {\n    optional: true\n  });\n}\n/**\r\n * Environment Initializer used in the root\r\n * providers to initialize the Store\r\n */\nconst ENVIRONMENT_STORE_PROVIDER = [{\n  provide: ROOT_STORE_PROVIDER,\n  useFactory: rootStoreProviderFactory\n}, provideEnvironmentInitializer(() => inject(ROOT_STORE_PROVIDER))];\n/**\r\n * Provides the global Store providers and initializes\r\n * the Store.\r\n * These providers cannot be used at the component level.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Providing the Global Store\r\n *\r\n * ```ts\r\n * bootstrapApplication(AppComponent, {\r\n *   providers: [provideStore()],\r\n * });\r\n * ```\r\n */\nfunction provideStore(reducers, config) {\n  return makeEnvironmentProviders([..._provideStore(reducers, config), ENVIRONMENT_STORE_PROVIDER]);\n}\nfunction featureStateProviderFactory() {\n  inject(ROOT_STORE_PROVIDER);\n  const features = inject(_STORE_FEATURES);\n  const featureReducers = inject(FEATURE_REDUCERS);\n  const reducerManager = inject(ReducerManager);\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, {\n    optional: true\n  });\n  const feats = features.map((feature, index) => {\n    const featureReducerCollection = featureReducers.shift();\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const reducers = featureReducerCollection /*TODO(#823)*/[index];\n    return {\n      ...feature,\n      reducers,\n      initialState: _initialStateFactory(feature.initialState)\n    };\n  });\n  reducerManager.addFeatures(feats);\n}\n/**\r\n * Environment Initializer used in the feature\r\n * providers to register state features\r\n */\nconst ENVIRONMENT_STATE_PROVIDER = [{\n  provide: FEATURE_STATE_PROVIDER,\n  useFactory: featureStateProviderFactory\n}, provideEnvironmentInitializer(() => inject(FEATURE_STATE_PROVIDER))];\nfunction _provideState(featureNameOrSlice, reducers, config = {}) {\n  return [{\n    provide: _FEATURE_CONFIGS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? {} : config\n  }, {\n    provide: STORE_FEATURES,\n    multi: true,\n    useValue: {\n      key: featureNameOrSlice instanceof Object ? featureNameOrSlice.name : featureNameOrSlice,\n      reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory ? config.reducerFactory : combineReducers,\n      metaReducers: !(config instanceof InjectionToken) && config.metaReducers ? config.metaReducers : [],\n      initialState: !(config instanceof InjectionToken) && config.initialState ? config.initialState : undefined\n    }\n  }, {\n    provide: _STORE_FEATURES,\n    deps: [_FEATURE_CONFIGS, STORE_FEATURES],\n    useFactory: _createFeatureStore\n  }, {\n    provide: _FEATURE_REDUCERS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? featureNameOrSlice.reducer : reducers\n  }, {\n    provide: _FEATURE_REDUCERS_TOKEN,\n    multi: true,\n    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS\n  }, {\n    provide: FEATURE_REDUCERS,\n    multi: true,\n    deps: [_FEATURE_REDUCERS, [new Inject(_FEATURE_REDUCERS_TOKEN)]],\n    useFactory: _createFeatureReducers\n  }, checkForActionTypeUniqueness()];\n}\nlet StoreRootModule = /*#__PURE__*/(() => {\n  var _staticBlock6;\n  class StoreRootModule {\n    constructor(actions$, reducer$, scannedActions$, store, guard, actionCheck) {}\n    /** @nocollapse */\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock6 = () => (this.ɵfac = function StoreRootModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || StoreRootModule)(i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerObservable), i0.ɵɵinject(ScannedActionsSubject), i0.ɵɵinject(Store), i0.ɵɵinject(_ROOT_STORE_GUARD, 8), i0.ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n    }, this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: StoreRootModule\n    }), this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  }\n  _staticBlock6();\n  return StoreRootModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet StoreFeatureModule = /*#__PURE__*/(() => {\n  var _staticBlock7;\n  class StoreFeatureModule {\n    constructor(features, featureReducers, reducerManager, root, actionCheck) {\n      this.features = features;\n      this.featureReducers = featureReducers;\n      this.reducerManager = reducerManager;\n      const feats = features.map((feature, index) => {\n        const featureReducerCollection = featureReducers.shift();\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const reducers = featureReducerCollection /*TODO(#823)*/[index];\n        return {\n          ...feature,\n          reducers,\n          initialState: _initialStateFactory(feature.initialState)\n        };\n      });\n      reducerManager.addFeatures(feats);\n    }\n    // eslint-disable-next-line @angular-eslint/contextual-lifecycle\n    ngOnDestroy() {\n      this.reducerManager.removeFeatures(this.features);\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock7 = () => (this.ɵfac = function StoreFeatureModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || StoreFeatureModule)(i0.ɵɵinject(_STORE_FEATURES), i0.ɵɵinject(FEATURE_REDUCERS), i0.ɵɵinject(ReducerManager), i0.ɵɵinject(StoreRootModule), i0.ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n    }, this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: StoreFeatureModule\n    }), this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  }\n  _staticBlock7();\n  return StoreFeatureModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet StoreModule = /*#__PURE__*/(() => {\n  var _staticBlock8;\n  class StoreModule {\n    static forRoot(reducers, config) {\n      return {\n        ngModule: StoreRootModule,\n        providers: [..._provideStore(reducers, config)]\n      };\n    }\n    static forFeature(featureNameOrSlice, reducers, config = {}) {\n      return {\n        ngModule: StoreFeatureModule,\n        providers: [..._provideState(featureNameOrSlice, reducers, config)]\n      };\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock8 = () => (this.ɵfac = function StoreModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || StoreModule)();\n    }, this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: StoreModule\n    }), this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  }\n  _staticBlock8();\n  return StoreModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * @description\r\n * Associates actions with a given state change function.\r\n * A state change function must be provided as the last parameter.\r\n *\r\n * @param args `ActionCreator`'s followed by a state change function.\r\n *\r\n * @returns an association of action types with a state change function.\r\n *\r\n * @usageNotes\r\n * ```ts\r\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\r\n * ```\r\n */\nfunction on(...args) {\n  const reducer = args.pop();\n  const types = args.map(creator => creator.type);\n  return {\n    reducer,\n    types\n  };\n}\n/**\r\n * @description\r\n * Creates a reducer function to handle state transitions.\r\n *\r\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\r\n *\r\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\r\n * @param ons Associations between actions and state changes.\r\n * @returns A reducer function.\r\n *\r\n * @usageNotes\r\n *\r\n * - Must be used with `ActionCreator`'s (returned by `createAction`). Cannot be used with class-based action creators.\r\n * - The returned `ActionReducer` does not require being wrapped with another function.\r\n *\r\n * **Declaring a reducer creator**\r\n *\r\n * ```ts\r\n * export const reducer = createReducer(\r\n *   initialState,\r\n *   on(\r\n *     featureActions.actionOne,\r\n *     featureActions.actionTwo,\r\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\r\n *   ),\r\n *   on(featureActions.actionThree, () => initialState);\r\n * );\r\n * ```\r\n */\nfunction createReducer(initialState, ...ons) {\n  const map = new Map();\n  for (const on of ons) {\n    for (const type of on.types) {\n      const existingReducer = map.get(type);\n      if (existingReducer) {\n        const newReducer = (state, action) => on.reducer(existingReducer(state, action), action);\n        map.set(type, newReducer);\n      } else {\n        map.set(type, on.reducer);\n      }\n    }\n  }\n  return function (state = initialState, action) {\n    const reducer = map.get(action.type);\n    return reducer ? reducer(state, action) : state;\n  };\n}\n\n/**\r\n * DO NOT EDIT\r\n *\r\n * This file is automatically generated at build\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { ACTIVE_RUNTIME_CHECKS, ActionsSubject, FEATURE_REDUCERS, FEATURE_STATE_PROVIDER, INIT, INITIAL_REDUCERS, INITIAL_STATE, META_REDUCERS, REDUCER_FACTORY, ROOT_STORE_PROVIDER, ReducerManager, ReducerManagerDispatcher, ReducerObservable, STORE_FEATURES, ScannedActionsSubject, State, StateObservable, Store, StoreFeatureModule, StoreModule, StoreRootModule, UPDATE, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, combineReducers, compose, createAction, createActionGroup, createFeature, createFeatureSelector, createReducer, createReducerFactory, createSelector, createSelectorFactory, defaultMemoize, defaultStateFn, emptyProps, isNgrxMockEnvironment, on, props, provideState, provideStore, reduceState, resultMemoize, select, setNgrxMockEnvironment, union };\n//# sourceMappingURL=ngrx-store.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}