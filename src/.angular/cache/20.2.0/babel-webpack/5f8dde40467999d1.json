{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/cedri/OneDrive/Documents/Typescript-Jasmine/src/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v20.2.1\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { NgZone, Injectable, DeferBlockState, triggerResourceLoading, renderDeferBlockState, getDeferBlocks, DeferBlockBehavior, NoopNgZone, ApplicationRef, getDebugNode, RendererFactory2, Directive, Component, Pipe, NgModule, ReflectionCapabilities, depsTracker, isComponentDefPendingResolution, resolveComponentResources, NgModuleRef, ApplicationInitStatus, LOCALE_ID, DEFAULT_LOCALE_ID, setLocaleId, ComponentFactory, getAsyncClassMetadataFn, compileComponent, compileDirective, compilePipe, patchComponentDefWithScope, compileNgModuleDefs, clearResolutionOfComponentResourcesQueue, restoreComponentResolutionQueue, internalProvideZoneChangeDetection, ChangeDetectionSchedulerImpl, COMPILER_OPTIONS, generateStandaloneInDeclarationsError, transitiveScopesFor, Compiler, DEFER_BLOCK_CONFIG, ANIMATIONS_DISABLED, NgModuleFactory, ModuleWithComponentFactories, resetCompiledComponents, ɵsetUnknownElementStrictMode as _setUnknownElementStrictMode, ɵsetUnknownPropertyStrictMode as _setUnknownPropertyStrictMode, ɵgetUnknownElementStrictMode as _getUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode as _getUnknownPropertyStrictMode, inferTagNameFromDefinition, flushModuleScopingQueueAsMuchAsPossible, setAllowDuplicateNgModuleIdsForTest } from './debug_node.mjs';\nimport { Subscription } from 'rxjs';\nimport { inject as inject$1, EnvironmentInjector, ErrorHandler, CONTAINER_HEADER_OFFSET, InjectionToken, PendingTasksInternal, ZONELESS_ENABLED, ChangeDetectionScheduler, EffectScheduler, stringify, getInjectableDef, resolveForwardRef, NG_COMP_DEF, NG_DIR_DEF, NG_PIPE_DEF, NG_INJ_DEF, NG_MOD_DEF, ENVIRONMENT_INITIALIZER, Injector, isEnvironmentProviders, INTERNAL_APPLICATION_ERROR_HANDLER, runInInjectionContext, getComponentDef as getComponentDef$1 } from './root_effect_scheduler.mjs';\nimport { ResourceLoader } from '@angular/compiler';\nimport './signal.mjs';\nimport '@angular/core/primitives/signals';\nimport 'rxjs/operators';\nimport './attribute.mjs';\nimport './not_found.mjs';\nimport '@angular/core/primitives/di';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```ts\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * })));\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\nconst RETHROW_APPLICATION_ERRORS_DEFAULT = true;\nlet TestBedApplicationErrorHandler = /*#__PURE__*/(() => {\n  class TestBedApplicationErrorHandler {\n    zone = inject$1(NgZone);\n    injector = inject$1(EnvironmentInjector);\n    userErrorHandler;\n    whenStableRejectFunctions = new Set();\n    handleError(e) {\n      try {\n        this.zone.runOutsideAngular(() => {\n          this.userErrorHandler ??= this.injector.get(ErrorHandler);\n          this.userErrorHandler.handleError(e);\n        });\n      } catch (userError) {\n        e = userError;\n      }\n      // Instead of throwing the error when there are outstanding `fixture.whenStable` promises,\n      // reject those promises with the error. This allows developers to write\n      // expectAsync(fix.whenStable()).toBeRejected();\n      if (this.whenStableRejectFunctions.size > 0) {\n        for (const fn of this.whenStableRejectFunctions.values()) {\n          fn(e);\n        }\n        this.whenStableRejectFunctions.clear();\n      } else {\n        throw e;\n      }\n    }\n    static ɵfac = function TestBedApplicationErrorHandler_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TestBedApplicationErrorHandler)();\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TestBedApplicationErrorHandler,\n      factory: TestBedApplicationErrorHandler.ɵfac\n    });\n  }\n  return TestBedApplicationErrorHandler;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents an individual defer block for testing purposes.\n *\n * @publicApi\n */\nclass DeferBlockFixture {\n  block;\n  componentFixture;\n  /** @docs-private */\n  constructor(block, componentFixture) {\n    this.block = block;\n    this.componentFixture = componentFixture;\n  }\n  /**\n   * Renders the specified state of the defer fixture.\n   * @param state the defer state to render\n   */\n  render(state) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!hasStateTemplate(state, _this.block)) {\n        const stateAsString = getDeferBlockStateNameFromEnum(state);\n        throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` + `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n      }\n      if (state === DeferBlockState.Complete) {\n        yield triggerResourceLoading(_this.block.tDetails, _this.block.lView, _this.block.tNode);\n      }\n      // If the `render` method is used explicitly - skip timer-based scheduling for\n      // `@placeholder` and `@loading` blocks and render them immediately.\n      const skipTimerScheduling = true;\n      renderDeferBlockState(state, _this.block.tNode, _this.block.lContainer, skipTimerScheduling);\n      _this.componentFixture.detectChanges();\n    })();\n  }\n  /**\n   * Retrieves all nested child defer block fixtures\n   * in a given defer block.\n   */\n  getDeferBlocks() {\n    const deferBlocks = [];\n    // An LContainer that represents a defer block has at most 1 view, which is\n    // located right after an LContainer header. Get a hold of that view and inspect\n    // it for nested defer blocks.\n    const deferBlockFixtures = [];\n    if (this.block.lContainer.length >= CONTAINER_HEADER_OFFSET) {\n      const lView = this.block.lContainer[CONTAINER_HEADER_OFFSET];\n      getDeferBlocks(lView, deferBlocks);\n      for (const block of deferBlocks) {\n        deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n      }\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n}\nfunction hasStateTemplate(state, block) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return block.tDetails.placeholderTmplIndex !== null;\n    case DeferBlockState.Loading:\n      return block.tDetails.loadingTmplIndex !== null;\n    case DeferBlockState.Error:\n      return block.tDetails.errorTmplIndex !== null;\n    case DeferBlockState.Complete:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return 'Placeholder';\n    case DeferBlockState.Loading:\n      return 'Loading';\n    case DeferBlockState.Error:\n      return 'Error';\n    default:\n      return 'Main';\n  }\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/** Whether defer blocks should use manual triggering or play through normally. */\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = DeferBlockBehavior.Playthrough;\n/** Whether animations are enabled or disabled. */\nconst ANIMATIONS_ENABLED_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n  insertRootElement(rootElementId, tagName) {}\n  removeAllRootElements() {}\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = /*#__PURE__*/new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = /*#__PURE__*/new InjectionToken('ComponentFixtureNoNgZone');\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n  componentRef;\n  /**\n   * The DebugElement associated with the root element of this component.\n   */\n  debugElement;\n  /**\n   * The instance of the root component class.\n   */\n  componentInstance;\n  /**\n   * The native element at the root of the component.\n   */\n  nativeElement;\n  /**\n   * The ElementRef for the element at the root of the component.\n   */\n  elementRef;\n  /**\n   * The ChangeDetectorRef for the component\n   */\n  changeDetectorRef;\n  _renderer;\n  _isDestroyed = false;\n  /** @internal */\n  _noZoneOptionIsSet = /*#__PURE__*/inject$1(ComponentFixtureNoNgZone, {\n    optional: true\n  });\n  /** @internal */\n  _ngZone = this._noZoneOptionIsSet ? /*#__PURE__*/new NoopNgZone() : /*#__PURE__*/inject$1(NgZone);\n  // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\n  // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\n  // This is a crazy way of doing things but hey, it's the world we live in.\n  // The zoneless scheduler should instead do this more imperatively by attaching\n  // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\n  // behavior.\n  /** @internal */\n  _appRef = /*#__PURE__*/inject$1(ApplicationRef);\n  _testAppRef = this._appRef;\n  pendingTasks = /*#__PURE__*/inject$1(PendingTasksInternal);\n  appErrorHandler = /*#__PURE__*/inject$1(TestBedApplicationErrorHandler);\n  zonelessEnabled = /*#__PURE__*/inject$1(ZONELESS_ENABLED);\n  scheduler = /*#__PURE__*/inject$1(ChangeDetectionScheduler);\n  rootEffectScheduler = /*#__PURE__*/inject$1(EffectScheduler);\n  autoDetectDefault = this.zonelessEnabled ? true : false;\n  autoDetect = /*#__PURE__*/inject$1(ComponentFixtureAutoDetect, {\n    optional: true\n  }) ?? this.autoDetectDefault;\n  subscriptions = /*#__PURE__*/new Subscription();\n  // TODO(atscott): Remove this from public API\n  ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n  /** @docs-private */\n  constructor(componentRef) {\n    this.componentRef = componentRef;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this._testAppRef.allTestViews.add(this.componentRef.hostView);\n    if (this.autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n      this.scheduler?.notify(8 /* ɵNotificationSource.ViewAttached */);\n      this.scheduler?.notify(0 /* ɵNotificationSource.MarkAncestorsForTraversal */);\n    }\n    this.componentRef.hostView.onDestroy(() => {\n      this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    });\n    // Create subscriptions outside the NgZone so that the callbacks run outside\n    // of NgZone.\n    this._ngZone.runOutsideAngular(() => {\n      this.subscriptions.add(this._ngZone.onError.subscribe({\n        next: error => {\n          // The rethrow here is to ensure that errors don't go unreported. Since `NgZone.onHandleError` returns `false`,\n          // ZoneJS will not throw the error coming out of a task. Instead, the handling is defined by\n          // the chain of parent delegates and whether they indicate the error is handled in some way (by returning `false`).\n          // Unfortunately, 'onError' does not forward the information about whether the error was handled by a parent zone\n          // so cannot know here whether throwing is appropriate. As a half-solution, we can check to see if we're inside\n          // a fakeAsync context, which we know has its own error handling.\n          // https://github.com/angular/angular/blob/db2f2d99c82aae52d8a0ae46616c6411d070b35e/packages/zone.js/lib/zone-spec/fake-async-test.ts#L783-L784\n          // https://github.com/angular/angular/blob/db2f2d99c82aae52d8a0ae46616c6411d070b35e/packages/zone.js/lib/zone-spec/fake-async-test.ts#L473-L478\n          if (typeof Zone === 'undefined' || Zone.current.get('FakeAsyncTestZoneSpec')) {\n            return;\n          }\n          throw error;\n        }\n      }));\n    });\n  }\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n  detectChanges(checkNoChanges = true) {\n    const originalCheckNoChanges = this.componentRef.changeDetectorRef.checkNoChanges;\n    try {\n      if (!checkNoChanges) {\n        this.componentRef.changeDetectorRef.checkNoChanges = () => {};\n      }\n      if (this.zonelessEnabled) {\n        try {\n          this._testAppRef.includeAllTestViews = true;\n          this._appRef.tick();\n        } finally {\n          this._testAppRef.includeAllTestViews = false;\n        }\n      } else {\n        // Run the change detection inside the NgZone so that any async tasks as part of the change\n        // detection are captured by the zone and can be waited for in isStable.\n        this._ngZone.run(() => {\n          // Flush root effects before `detectChanges()`, to emulate the sequencing of `tick()`.\n          this.rootEffectScheduler.flush();\n          this.changeDetectorRef.detectChanges();\n          this.checkNoChanges();\n        });\n      }\n    } finally {\n      this.componentRef.changeDetectorRef.checkNoChanges = originalCheckNoChanges;\n    }\n  }\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  autoDetectChanges(autoDetect = true) {\n    if (!autoDetect && this.zonelessEnabled) {\n      throw new Error('Cannot set autoDetect to false with zoneless change detection.');\n    }\n    if (this._noZoneOptionIsSet && !this.zonelessEnabled) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n    }\n    if (autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n    } else {\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    }\n    this.autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n  isStable() {\n    return !this.pendingTasks.hasPendingTasks;\n  }\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    }\n    return new Promise((resolve, reject) => {\n      this.appErrorHandler.whenStableRejectFunctions.add(reject);\n      this._appRef.whenStable().then(() => {\n        this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n        resolve(true);\n      });\n    });\n  }\n  /**\n   * Retrieves all defer block fixtures in the component fixture.\n   */\n  getDeferBlocks() {\n    const deferBlocks = [];\n    const lView = this.componentRef.hostView['_lView'];\n    getDeferBlocks(lView, deferBlocks);\n    const deferBlockFixtures = [];\n    for (const block of deferBlocks) {\n      deferBlockFixtures.push(new DeferBlockFixture(block, this));\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer;\n  }\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n  /**\n   * Trigger component destruction.\n   */\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      this._isDestroyed = true;\n    }\n  }\n}\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nfunction getFakeAsyncTestModule() {\n  return _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n}\nfunction withFakeAsyncTestModule(fn) {\n  const fakeAsyncTestModule = getFakeAsyncTestModule();\n  if (!fakeAsyncTestModule) {\n    throw new Error(`zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`);\n  }\n  return fn(fakeAsyncTestModule);\n}\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n  withFakeAsyncTestModule(v => v.resetFakeAsyncZone());\n}\nfunction resetFakeAsyncZoneIfExists() {\n  if (getFakeAsyncTestModule() && Zone['ProxyZoneSpec']?.isLoaded()) {\n    getFakeAsyncTestModule().resetFakeAsyncZone();\n  }\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n * @param options\n *   - flush: When true, will drain the macrotask queue after the test function completes.\n *     When false, will throw an exception at the end of the function if there are pending timers.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn, options) {\n  return withFakeAsyncTestModule(v => v.fakeAsync(fn, options));\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  return withFakeAsyncTestModule(m => m.tick(millis, tickOptions));\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n  return withFakeAsyncTestModule(m => m.flush(maxTurns));\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n  return withFakeAsyncTestModule(m => m.discardPeriodicTasks());\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n  return withFakeAsyncTestModule(m => m.flushMicrotasks());\n}\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n  _references = /*#__PURE__*/new Map();\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(props);\n  }\n}\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      }\n      // Record an id for this object such that any later references use the object's id instead\n      // of the object itself, in order to break cyclic pointers in objects.\n      objectIds.set(value, `ɵobj#${nextObjectId++}`);\n      // The first time an object is seen the object itself is serialized.\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${stringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\nfunction _valueProps(obj) {\n  const props = [];\n  // regular public props\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n  // getters\n  let proto = obj;\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\nconst reflection = /*#__PURE__*/new ReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n  overrides = /*#__PURE__*/new Map();\n  resolved = /*#__PURE__*/new Map();\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type);\n    // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n    return null;\n  }\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n    return resolved;\n  }\n}\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n}\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n}\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n}\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n}\nvar TestingModuleOverride = /*#__PURE__*/function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n  return TestingModuleOverride;\n}(TestingModuleOverride || {});\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n  types.forEach(type => {\n    if (!getAsyncClassMetadataFn(type)) {\n      const component = resolver.resolve(type);\n      if (component && (component.standalone == null || component.standalone)) {\n        throw new Error(generateStandaloneInDeclarationsError(type, location));\n      }\n    }\n  });\n}\nclass TestBedCompiler {\n  platform;\n  additionalModuleTypes;\n  originalComponentResolutionQueue = null;\n  // Testing module configuration\n  declarations = [];\n  imports = [];\n  providers = [];\n  schemas = [];\n  // Queues of components/directives/pipes that should be recompiled.\n  pendingComponents = /*#__PURE__*/new Set();\n  pendingDirectives = /*#__PURE__*/new Set();\n  pendingPipes = /*#__PURE__*/new Set();\n  // Set of components with async metadata, i.e. components with `@defer` blocks\n  // in their templates.\n  componentsWithAsyncMetadata = /*#__PURE__*/new Set();\n  // Keep track of all components and directives, so we can patch Providers onto defs later.\n  seenComponents = /*#__PURE__*/new Set();\n  seenDirectives = /*#__PURE__*/new Set();\n  // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n  overriddenModules = /*#__PURE__*/new Set();\n  // Store resolved styles for Components that have template overrides present and `styleUrls`\n  // defined at the same time.\n  existingComponentStyles = /*#__PURE__*/new Map();\n  resolvers = /*#__PURE__*/initResolvers();\n  // Map of component type to an NgModule that declares it.\n  //\n  // There are a couple special cases:\n  // - for standalone components, the module scope value is `null`\n  // - when a component is declared in `TestBed.configureTestingModule()` call or\n  //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n  //   we use a special value from the `TestingModuleOverride` enum.\n  componentToModuleScope = /*#__PURE__*/new Map();\n  // Map that keeps initial version of component/directive/pipe defs in case\n  // we compile a Type again, thus overriding respective static fields. This is\n  // required to make sure we restore defs to their initial states between test runs.\n  // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n  // NgModule), store all of them in a map.\n  initialNgDefs = /*#__PURE__*/new Map();\n  // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n  // defs in case TestBed makes changes to the originals.\n  defCleanupOps = [];\n  _injector = null;\n  compilerProviders = null;\n  providerOverrides = [];\n  rootProviderOverrides = [];\n  // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n  // module's provider list.\n  providerOverridesByModule = /*#__PURE__*/new Map();\n  providerOverridesByToken = /*#__PURE__*/new Map();\n  scopesWithOverriddenProviders = /*#__PURE__*/new Set();\n  testModuleType;\n  testModuleRef = null;\n  animationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n  deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule;\n  }\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n  configureTestingModule(moduleDef) {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      // Verify that there are no standalone components\n      assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n    // Enqueue any compilation tasks for imported modules.\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n    this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this.animationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    this.rethrowApplicationTickErrors = moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n  }\n  overrideModule(ngModule, override) {\n    depsTracker.clearScopeCacheFor(ngModule);\n    this.overriddenModules.add(ngModule);\n    // Compile the module right away.\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n    this.recompileNgModule(ngModule, metadata);\n    // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n  overrideComponent(component, override) {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(component);\n  }\n  overrideDirective(directive, override) {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n  overridePipe(pipe, override) {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n  verifyNoStandaloneFlagOverrides(type, override) {\n    if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') || override.remove?.hasOwnProperty('standalone')) {\n      throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` + `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n    }\n  }\n  overrideProvider(token, provider) {\n    let providerDef;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n    const injectableDef = typeof token !== 'string' ? getInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n    // Keep overrides grouped by token as well for fast lookups using token\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[NG_COMP_DEF];\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n    };\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n    // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: [],\n      styleUrl: undefined\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n    // Set the component's scope to be the testing module.\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n  resolvePendingComponentsWithAsyncMetadata() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.componentsWithAsyncMetadata.size === 0) return;\n      const promises = [];\n      for (const component of _this2.componentsWithAsyncMetadata) {\n        const asyncMetadataFn = getAsyncClassMetadataFn(component);\n        if (asyncMetadataFn) {\n          promises.push(asyncMetadataFn());\n        }\n      }\n      _this2.componentsWithAsyncMetadata.clear();\n      const resolvedDeps = yield Promise.all(promises);\n      const flatResolvedDeps = resolvedDeps.flat(2);\n      _this2.queueTypesFromModulesArray(flatResolvedDeps);\n      // Loaded standalone components might contain imports of NgModules\n      // with providers, make sure we override providers there too.\n      for (const component of flatResolvedDeps) {\n        _this2.applyProviderOverridesInScope(component);\n      }\n    })();\n  }\n  compileComponents() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.clearComponentResolutionQueue();\n      // Wait for all async metadata for components that were\n      // overridden, we need resolved metadata to perform an override\n      // and re-compile a component.\n      yield _this3.resolvePendingComponentsWithAsyncMetadata();\n      // Verify that there were no standalone components present in the `declarations` field\n      // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n      // to the logic in the `configureTestingModule` function, since at this point we have\n      // all async metadata resolved.\n      assertNoStandaloneComponents(_this3.declarations, _this3.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      // Run compilers for all queued types.\n      let needsAsyncResources = _this3.compileTypesSync();\n      // compileComponents() should not be async unless it needs to be.\n      if (needsAsyncResources) {\n        let resourceLoader;\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = _this3.injector.get(ResourceLoader);\n          }\n          return Promise.resolve(resourceLoader.get(url));\n        };\n        yield resolveComponentResources(resolver);\n      }\n    })();\n  }\n  finalize() {\n    // One last compile\n    this.compileTypesSync();\n    // Create the testing module itself.\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides();\n    // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n    this.patchComponentsWithExistingStyles();\n    // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector, []);\n    // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n    // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n    setLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  /**\n   * @internal\n   */\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  /**\n   * @internal\n   */\n  _compileNgModuleAsync(moduleType) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.queueTypesFromModulesArray([moduleType]);\n      yield _this4.compileComponents();\n      _this4.applyProviderOverrides();\n      _this4.applyProviderOverridesInScope(moduleType);\n      _this4.applyTransitiveScopes();\n    })();\n  }\n  /**\n   * @internal\n   */\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  /**\n   * @internal\n   */\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n  compileTypesSync() {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      if (getAsyncClassMetadataFn(declaration)) {\n        throw new Error(`Component '${declaration.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n      }\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n      this.maybeStoreNgDef(NG_COMP_DEF, declaration);\n      depsTracker.clearScopeCacheFor(declaration);\n      compileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(NG_DIR_DEF, declaration);\n      compileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(NG_PIPE_DEF, declaration);\n      compilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = this.testModuleType[NG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          depsTracker.clearScopeCacheFor(moduleType);\n        });\n      }\n    }\n    const moduleToScope = new Map();\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, transitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType);\n    };\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      if (moduleType !== null) {\n        const moduleScope = getScopeOfModule(moduleType);\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'directiveDefs');\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'pipeDefs');\n        patchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n      }\n      // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n      // Resetting `tView` is also needed for cases when we apply provider overrides and those\n      // providers are defined on component's level, in which case they may end up included into\n      // `tView.blueprint`.\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'tView');\n    });\n    this.componentToModuleScope.clear();\n  }\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n  /**\n   * Applies provider overrides to a given type (either an NgModule or a standalone component)\n   * and all imported NgModules and standalone components recursively.\n   */\n  applyProviderOverridesInScope(type) {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n    // The function can be re-entered recursively while inspecting dependencies\n    // of an NgModule or a standalone component. Exit early if we come across a\n    // type that can not have a scope (directive or pipe) or the type is already\n    // processed earlier.\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n    // NOTE: the line below triggers JIT compilation of the module injector,\n    // which also invokes verification of the NgModule semantics, which produces\n    // detailed error messages. The fact that the code relies on this line being\n    // present here is suspicious and should be refactored in a way that the line\n    // below can be moved (for ex. after an early exit check below).\n    const injectorDef = type[NG_INJ_DEF];\n    // No provider overrides, exit early.\n    if (this.providerOverridesByToken.size === 0) return;\n    if (isStandaloneComponent(type)) {\n      // Visit all component dependencies and override providers there.\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(type) || [])];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(NG_INJ_DEF, type);\n        this.storeFieldOfDefOnType(type, NG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n      // Apply provider overrides to imported modules recursively\n      const moduleDef = type[NG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[NG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n  recompileNgModule(ngModule, metadata) {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(NG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(NG_INJ_DEF, ngModule);\n    compileNgModuleDefs(ngModule, metadata);\n  }\n  maybeRegisterComponentWithAsyncMetadata(type) {\n    const asyncMetadataFn = getAsyncClassMetadataFn(type);\n    if (asyncMetadataFn) {\n      this.componentsWithAsyncMetadata.add(type);\n    }\n  }\n  queueType(type, moduleType) {\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(type);\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n      // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(NG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n  queueTypesFromModulesArray(arr) {\n    // Because we may encounter the same NgModule or a standalone Component while processing\n    // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n    // can skip ones that have already been seen encountered. In some test setups, this caching\n    // resulted in 10X runtime improvement.\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          // Look through declarations, imports, and exports, and queue\n          // everything found there.\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach(dependency => {\n            // Note: in AOT, the `dependencies` might also contain regular\n            // (NgModule-based) Component, Directive and Pipes, so we handle\n            // them separately and proceed with recursive process for standalone\n            // Components and NgModules only.\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n  // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          }\n          // Examine module imports recursively to look for overridden modules.\n          const moduleDef = value[NG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n  /**\n   * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n   * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n   * an NgModule). If there is a def in a set already, don't override it, since\n   * an original one should be restored at the end of a test.\n   */\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type);\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n  restoreOriginalState() {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    // Restore initial component/directive/pipe defs\n    this.initialNgDefs.forEach((defs, type) => {\n      depsTracker.clearScopeCacheFor(type);\n      defs.forEach((descriptor, prop) => {\n        if (!descriptor) {\n          // Delete operations are generally undesirable since they have performance\n          // implications on objects they were applied to. In this particular case, situations\n          // where this code is invoked should be quite rare to cause any noticeable impact,\n          // since it's applied only to some test cases (for example when class with no\n          // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n          // class to restore its original state (before applying overrides and running tests).\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n    });\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n    setLocaleId(DEFAULT_LOCALE_ID);\n  }\n  compileTestModule() {\n    class RootScopeModule {}\n    compileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides, internalProvideZoneChangeDetection({}), TestBedApplicationErrorHandler, {\n        provide: ChangeDetectionScheduler,\n        useExisting: ChangeDetectionSchedulerImpl\n      }, {\n        provide: ENVIRONMENT_INITIALIZER,\n        multi: true,\n        useValue: () => {\n          inject$1(ErrorHandler);\n        }\n      }]\n    });\n    const providers = [{\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, {\n      provide: DEFER_BLOCK_CONFIG,\n      useValue: {\n        behavior: this.deferBlockBehavior\n      }\n    }, {\n      provide: ANIMATIONS_DISABLED,\n      useValue: !this.animationsEnabled\n    }, {\n      provide: INTERNAL_APPLICATION_ERROR_HANDLER,\n      useFactory: () => {\n        if (this.rethrowApplicationTickErrors) {\n          const handler = inject$1(TestBedApplicationErrorHandler);\n          return e => {\n            handler.handleError(e);\n          };\n        } else {\n          const userErrorHandler = inject$1(ErrorHandler);\n          const ngZone = inject$1(NgZone);\n          return e => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n        }\n      }\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n    compileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    }, /* allowDuplicateDeclarationsInRoot */true);\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    }\n    this._injector = Injector.create({\n      providers,\n      parent: this.platform.injector\n    });\n    return this._injector;\n  }\n  // get overrides for a specific provider (if any)\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    // There are two flattening operations here. The inner flattenProviders() operates on the\n    // metadata's providers and applies a mapping function which retrieves overrides for each\n    // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n    // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n    return flatten(flattenProviders(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set();\n    // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n          final.unshift({\n            ...provider,\n            multi: false\n          });\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n  return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n  return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\nfunction identityFn(value) {\n  return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n  const out = [];\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n  testBed;\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new NgModuleFactory(moduleType);\n  }\n  compileModuleAsync(moduleType) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.testBed._compileNgModuleAsync(moduleType);\n      return new NgModuleFactory(moduleType);\n    })();\n  }\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  compileModuleAndAllComponentsAsync(moduleType) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const ngModuleFactory = yield _this6.compileModuleAsync(moduleType);\n      const componentFactories = _this6.testBed._getComponentFactories(moduleType);\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    })();\n  }\n  clearCache() {}\n  clearCacheFor(type) {}\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return meta && meta.id || undefined;\n  }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\n// it on one line, too, which has gotten very hard to read & manage. So disable the formatter for\n// this statement only.\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n  return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nlet TestBedImpl = /*#__PURE__*/(() => {\n  class TestBedImpl {\n    static _INSTANCE = null;\n    static get INSTANCE() {\n      return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n    }\n    /**\n     * Teardown options that have been configured at the environment level.\n     * Used as a fallback if no instance-level options have been provided.\n     */\n    static _environmentTeardownOptions;\n    /**\n     * \"Error on unknown elements\" option that has been configured at the environment level.\n     * Used as a fallback if no instance-level option has been provided.\n     */\n    static _environmentErrorOnUnknownElementsOption;\n    /**\n     * \"Error on unknown properties\" option that has been configured at the environment level.\n     * Used as a fallback if no instance-level option has been provided.\n     */\n    static _environmentErrorOnUnknownPropertiesOption;\n    /**\n     * Teardown options that have been configured at the `TestBed` instance level.\n     * These options take precedence over the environment-level ones.\n     */\n    _instanceTeardownOptions;\n    /**\n     * Defer block behavior option that specifies whether defer blocks will be triggered manually\n     * or set to play through.\n     */\n    _instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    /**\n     * Animations behavior option that specifies whether animations are enabled or disabled.\n     */\n    _instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n    /**\n     * \"Error on unknown elements\" option that has been configured at the `TestBed` instance level.\n     * This option takes precedence over the environment-level one.\n     */\n    _instanceErrorOnUnknownElementsOption;\n    /**\n     * \"Error on unknown properties\" option that has been configured at the `TestBed` instance level.\n     * This option takes precedence over the environment-level one.\n     */\n    _instanceErrorOnUnknownPropertiesOption;\n    /**\n     * Stores the previous \"Error on unknown elements\" option value,\n     * allowing to restore it in the reset testing module logic.\n     */\n    _previousErrorOnUnknownElementsOption;\n    /**\n     * Stores the previous \"Error on unknown properties\" option value,\n     * allowing to restore it in the reset testing module logic.\n     */\n    _previousErrorOnUnknownPropertiesOption;\n    /**\n     * Stores the value for `inferTagName` from the testing module.\n     */\n    _instanceInferTagName;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, options) {\n      const testBed = TestBedImpl.INSTANCE;\n      testBed.initTestEnvironment(ngModule, platform, options);\n      return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n      TestBedImpl.INSTANCE.resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n      return TestBedImpl.INSTANCE.configureCompiler(config);\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n      return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n      return TestBedImpl.INSTANCE.compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n      return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n    }\n    static overrideComponent(component, override) {\n      return TestBedImpl.INSTANCE.overrideComponent(component, override);\n    }\n    static overrideDirective(directive, override) {\n      return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n    }\n    static overridePipe(pipe, override) {\n      return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n    }\n    static overrideTemplate(component, template) {\n      return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n      return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n    }\n    static overrideProvider(token, provider) {\n      return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n    }\n    static inject(token, notFoundValue, options) {\n      return TestBedImpl.INSTANCE.inject(token, notFoundValue, options);\n    }\n    /**\n     * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n     *\n     * @see {@link https://angular.dev/api/core/EnvironmentInjector#runInContext}\n     */\n    static runInInjectionContext(fn) {\n      return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n    }\n    static createComponent(component, options) {\n      return TestBedImpl.INSTANCE.createComponent(component, options);\n    }\n    static resetTestingModule() {\n      return TestBedImpl.INSTANCE.resetTestingModule();\n    }\n    static execute(tokens, fn, context) {\n      return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n    }\n    static get platform() {\n      return TestBedImpl.INSTANCE.platform;\n    }\n    static get ngModule() {\n      return TestBedImpl.INSTANCE.ngModule;\n    }\n    static flushEffects() {\n      return TestBedImpl.INSTANCE.tick();\n    }\n    static tick() {\n      return TestBedImpl.INSTANCE.tick();\n    }\n    // Properties\n    platform = null;\n    ngModule = null;\n    _compiler = null;\n    _testModuleRef = null;\n    _activeFixtures = [];\n    /**\n     * Internal-only flag to indicate whether a module\n     * scoping queue has been checked and flushed already.\n     * @docs-private\n     */\n    globalCompilationChecked = false;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, options) {\n      if (this.platform || this.ngModule) {\n        throw new Error('Cannot set base providers because it has already been called');\n      }\n      TestBedImpl._environmentTeardownOptions = options?.teardown;\n      TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n      TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n      this.platform = platform;\n      this.ngModule = ngModule;\n      this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n      // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n      // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n      // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n      // completely.\n      setAllowDuplicateNgModuleIdsForTest(true);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n      this.resetTestingModule();\n      this._compiler = null;\n      this.platform = null;\n      this.ngModule = null;\n      TestBedImpl._environmentTeardownOptions = undefined;\n      setAllowDuplicateNgModuleIdsForTest(false);\n    }\n    resetTestingModule() {\n      this.checkGlobalCompilationFinished();\n      resetCompiledComponents();\n      if (this._compiler !== null) {\n        this.compiler.restoreOriginalState();\n      }\n      this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n      // Restore the previous value of the \"error on unknown elements\" option\n      _setUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n      // Restore the previous value of the \"error on unknown properties\" option\n      _setUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n      // We have to chain a couple of try/finally blocks, because each step can\n      // throw errors and we don't want it to interrupt the next step and we also\n      // want an error to be thrown at the end.\n      try {\n        this.destroyActiveFixtures();\n      } finally {\n        try {\n          if (this.shouldTearDownTestingModule()) {\n            this.tearDownTestingModule();\n          }\n        } finally {\n          this._testModuleRef = null;\n          this._instanceTeardownOptions = undefined;\n          this._instanceErrorOnUnknownElementsOption = undefined;\n          this._instanceErrorOnUnknownPropertiesOption = undefined;\n          this._instanceInferTagName = undefined;\n          this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n          this._instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n        }\n      }\n      return this;\n    }\n    configureCompiler(config) {\n      if (config.useJit != null) {\n        throw new Error('JIT compiler is not configurable via TestBed APIs.');\n      }\n      if (config.providers !== undefined) {\n        this.compiler.setCompilerProviders(config.providers);\n      }\n      return this;\n    }\n    configureTestingModule(moduleDef) {\n      this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n      // Trigger module scoping queue flush before executing other TestBed operations in a test.\n      // This is needed for the first test invocation to ensure that globally declared modules have\n      // their components scoped properly. See the `checkGlobalCompilationFinished` function\n      // description for additional info.\n      this.checkGlobalCompilationFinished();\n      // Always re-assign the options, even if they're undefined.\n      // This ensures that we don't carry them between tests.\n      this._instanceTeardownOptions = moduleDef.teardown;\n      this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n      this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n      this._instanceInferTagName = moduleDef.inferTagName;\n      this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n      this._instanceAnimationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n      // Store the current value of the strict mode option,\n      // so we can restore it later\n      this._previousErrorOnUnknownElementsOption = _getUnknownElementStrictMode();\n      _setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n      this._previousErrorOnUnknownPropertiesOption = _getUnknownPropertyStrictMode();\n      _setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n      this.compiler.configureTestingModule(moduleDef);\n      return this;\n    }\n    compileComponents() {\n      return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, options) {\n      if (token === TestBed) {\n        return this;\n      }\n      const UNDEFINED = {};\n      const result = this.testModuleRef.injector.get(token, UNDEFINED, options);\n      return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, options) : result;\n    }\n    runInInjectionContext(fn) {\n      return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n    }\n    execute(tokens, fn, context) {\n      const params = tokens.map(t => this.inject(t));\n      return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n      this.assertNotInstantiated('overrideModule', 'override module metadata');\n      this.compiler.overrideModule(ngModule, override);\n      return this;\n    }\n    overrideComponent(component, override) {\n      this.assertNotInstantiated('overrideComponent', 'override component metadata');\n      this.compiler.overrideComponent(component, override);\n      return this;\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n      this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n      this.compiler.overrideTemplateUsingTestingModule(component, template);\n      return this;\n    }\n    overrideDirective(directive, override) {\n      this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n      this.compiler.overrideDirective(directive, override);\n      return this;\n    }\n    overridePipe(pipe, override) {\n      this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n      this.compiler.overridePipe(pipe, override);\n      return this;\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n      this.assertNotInstantiated('overrideProvider', 'override provider');\n      this.compiler.overrideProvider(token, provider);\n      return this;\n    }\n    overrideTemplate(component, template) {\n      return this.overrideComponent(component, {\n        set: {\n          template,\n          templateUrl: null\n        }\n      });\n    }\n    createComponent(type, options) {\n      if (getAsyncClassMetadataFn(type)) {\n        throw new Error(`Component '${type.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n      }\n      // Note: injecting the renderer before accessing the definition appears to be load-bearing.\n      const testComponentRenderer = this.inject(TestComponentRenderer);\n      const shouldInferTagName = options?.inferTagName ?? this._instanceInferTagName ?? false;\n      const componentDef = getComponentDef$1(type);\n      const rootElId = `root${_nextRootElementId++}`;\n      if (!componentDef) {\n        throw new Error(`It looks like '${stringify(type)}' has not been compiled.`);\n      }\n      testComponentRenderer.insertRootElement(rootElId, shouldInferTagName ? inferTagNameFromDefinition(componentDef) : undefined);\n      const componentFactory = new ComponentFactory(componentDef);\n      const initComponent = () => {\n        const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef, undefined, options?.bindings);\n        return this.runInInjectionContext(() => new ComponentFixture(componentRef));\n      };\n      const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n      const ngZone = noNgZone ? null : this.inject(NgZone, null);\n      const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n      this._activeFixtures.push(fixture);\n      return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n      if (this._compiler === null) {\n        throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n      }\n      return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n      if (this._testModuleRef === null) {\n        this._testModuleRef = this.compiler.finalize();\n      }\n      return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n      if (this._testModuleRef !== null) {\n        throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n      }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n      // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n      // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n      if (!this.globalCompilationChecked && this._testModuleRef === null) {\n        flushModuleScopingQueueAsMuchAsPossible();\n      }\n      this.globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n      let errorCount = 0;\n      this._activeFixtures.forEach(fixture => {\n        try {\n          fixture.destroy();\n        } catch (e) {\n          errorCount++;\n          console.error('Error during cleanup of component', {\n            component: fixture.componentInstance,\n            stacktrace: e\n          });\n        }\n      });\n      this._activeFixtures = [];\n      if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n        throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n      }\n    }\n    shouldRethrowTeardownErrors() {\n      const instanceOptions = this._instanceTeardownOptions;\n      const environmentOptions = TestBedImpl._environmentTeardownOptions;\n      // If the new teardown behavior hasn't been configured, preserve the old behavior.\n      if (!instanceOptions && !environmentOptions) {\n        return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n      }\n      // Otherwise use the configured behavior or default to rethrowing.\n      return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n    }\n    shouldThrowErrorOnUnknownElements() {\n      // Check if a configuration has been provided to throw when an unknown element is found\n      return this._instanceErrorOnUnknownElementsOption ?? TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n    }\n    shouldThrowErrorOnUnknownProperties() {\n      // Check if a configuration has been provided to throw when an unknown property is found\n      return this._instanceErrorOnUnknownPropertiesOption ?? TestBedImpl._environmentErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n    }\n    shouldTearDownTestingModule() {\n      return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedImpl._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    getDeferBlockBehavior() {\n      return this._instanceDeferBlockBehavior;\n    }\n    getAnimationsEnabled() {\n      return this._instanceAnimationsEnabled;\n    }\n    tearDownTestingModule() {\n      // If the module ref has already been destroyed, we won't be able to get a test renderer.\n      if (this._testModuleRef === null) {\n        return;\n      }\n      // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n      // last step, but the injector will be destroyed as a part of the module ref destruction.\n      const testRenderer = this.inject(TestComponentRenderer);\n      try {\n        this._testModuleRef.destroy();\n      } catch (e) {\n        if (this.shouldRethrowTeardownErrors()) {\n          throw e;\n        } else {\n          console.error('Error during cleanup of a testing module', {\n            component: this._testModuleRef.instance,\n            stacktrace: e\n          });\n        }\n      } finally {\n        testRenderer.removeAllRootElements?.();\n      }\n    }\n    /**\n     * Execute any pending effects by executing any pending work required to synchronize model to the UI.\n     *\n     * @deprecated use `TestBed.tick()` instead\n     */\n    flushEffects() {\n      this.tick();\n    }\n    /**\n     * Execute any pending work required to synchronize model to the UI.\n     *\n     * @publicApi\n     */\n    tick() {\n      const appRef = this.inject(ApplicationRef);\n      try {\n        // TODO(atscott): ApplicationRef.tick should set includeAllTestViews to true itself rather than doing this here and in ComponentFixture\n        // The behavior should be that TestBed.tick, ComponentFixture.detectChanges, and ApplicationRef.tick all result in the test fixtures\n        // getting synchronized, regardless of whether they are autoDetect: true.\n        // Automatic scheduling (zone or zoneless) will call _tick which will _not_ include fixtures with autoDetect: false\n        appRef.includeAllTestViews = true;\n        appRef.tick();\n      } finally {\n        appRef.includeAllTestViews = false;\n      }\n    }\n  }\n  return TestBedImpl;\n})();\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```ts\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n  const testBed = TestBedImpl.INSTANCE;\n  // Not using an arrow function to preserve context passed from call site\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n  _moduleDef;\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n  _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      TestBedImpl.configureTestingModule(moduleDef);\n    }\n  }\n  inject(tokens, fn) {\n    const self = this;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      const testBed = TestBedImpl.INSTANCE;\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * Fake implementation of user agent history and navigation behavior. This is a\n * high-fidelity implementation of browser behavior that attempts to emulate\n * things like traversal delay.\n */\nclass FakeNavigation {\n  /**\n   * The fake implementation of an entries array. Only same-document entries\n   * allowed.\n   */\n  entriesArr = [];\n  /**\n   * The current active entry index into `entriesArr`.\n   */\n  currentEntryIndex = 0;\n  /**\n   * The current navigate event.\n   * @internal\n   */\n  navigateEvent = null;\n  /**\n   * A Map of pending traversals, so that traversals to the same entry can be\n   * re-used.\n   */\n  traversalQueue = /*#__PURE__*/new Map();\n  /**\n   * A Promise that resolves when the previous traversals have finished. Used to\n   * simulate the cross-process communication necessary for traversals.\n   */\n  nextTraversal = /*#__PURE__*/Promise.resolve();\n  /**\n   * A prospective current active entry index, which includes unresolved\n   * traversals. Used by `go` to determine where navigations are intended to go.\n   */\n  prospectiveEntryIndex = 0;\n  /**\n   * A test-only option to make traversals synchronous, rather than emulate\n   * cross-process communication.\n   */\n  synchronousTraversals = false;\n  /** Whether to allow a call to setInitialEntryForTesting. */\n  canSetInitialEntry = true;\n  /**\n   * `EventTarget` to dispatch events.\n   * @internal\n   */\n  eventTarget;\n  /** The next unique id for created entries. Replace recreates this id. */\n  nextId = 0;\n  /** The next unique key for created entries. Replace inherits this id. */\n  nextKey = 0;\n  /** Whether this fake is disposed. */\n  disposed = false;\n  /** Equivalent to `navigation.currentEntry`. */\n  get currentEntry() {\n    return this.entriesArr[this.currentEntryIndex];\n  }\n  get canGoBack() {\n    return this.currentEntryIndex > 0;\n  }\n  get canGoForward() {\n    return this.currentEntryIndex < this.entriesArr.length - 1;\n  }\n  createEventTarget;\n  _window;\n  get window() {\n    return this._window;\n  }\n  constructor(doc, startURL) {\n    this.createEventTarget = () => {\n      try {\n        // `document.createElement` because NodeJS `EventTarget` is\n        // incompatible with Domino's `Event`. That is, attempting to\n        // dispatch an event created by Domino's patched `Event` will\n        // throw an error since it is not an instance of a real Node\n        // `Event`.\n        return doc.createElement('div');\n      } catch {\n        // Fallback to a basic EventTarget if `document.createElement`\n        // fails. This can happen with tests that pass in a value for document\n        // that is stubbed.\n        return new EventTarget();\n      }\n    };\n    this._window = document.defaultView ?? this.createEventTarget();\n    this.eventTarget = this.createEventTarget();\n    // First entry.\n    this.setInitialEntryForTesting(startURL);\n  }\n  /**\n   * Sets the initial entry.\n   */\n  setInitialEntryForTesting(url, options = {\n    historyState: null\n  }) {\n    if (!this.canSetInitialEntry) {\n      throw new Error('setInitialEntryForTesting can only be called before any ' + 'navigation has occurred');\n    }\n    const currentInitialEntry = this.entriesArr[0];\n    this.entriesArr[0] = new FakeNavigationHistoryEntry(this.eventTarget, new URL(url).toString(), {\n      index: 0,\n      key: currentInitialEntry?.key ?? String(this.nextKey++),\n      id: currentInitialEntry?.id ?? String(this.nextId++),\n      sameDocument: true,\n      historyState: options?.historyState,\n      state: options.state\n    });\n  }\n  /** Returns whether the initial entry is still eligible to be set. */\n  canSetInitialEntryForTesting() {\n    return this.canSetInitialEntry;\n  }\n  /**\n   * Sets whether to emulate traversals as synchronous rather than\n   * asynchronous.\n   */\n  setSynchronousTraversalsForTesting(synchronousTraversals) {\n    this.synchronousTraversals = synchronousTraversals;\n  }\n  /** Equivalent to `navigation.entries()`. */\n  entries() {\n    return this.entriesArr.slice();\n  }\n  /** Equivalent to `navigation.navigate()`. */\n  navigate(url, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = new URL(url, this.currentEntry.url);\n    let navigationType;\n    if (!options?.history || options.history === 'auto') {\n      // Auto defaults to push, but if the URLs are the same, is a replace.\n      if (fromUrl.toString() === toUrl.toString()) {\n        navigationType = 'replace';\n      } else {\n        navigationType = 'push';\n      }\n    } else {\n      navigationType = options.history;\n    }\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      state: options?.state,\n      sameDocument: hashChange,\n      historyState: null\n    });\n    const result = new InternalNavigationResult(this);\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      // Always false for navigate().\n      userInitiated: false,\n      hashChange,\n      info: options?.info\n    });\n    if (!intercepted) {\n      this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n    }\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  /** Equivalent to `history.pushState()`. */\n  pushState(data, title, url) {\n    this.pushOrReplaceState('push', data, title, url);\n  }\n  /** Equivalent to `history.replaceState()`. */\n  replaceState(data, title, url) {\n    this.pushOrReplaceState('replace', data, title, url);\n  }\n  pushOrReplaceState(navigationType, data, _title, url) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = url ? new URL(url, this.currentEntry.url) : fromUrl;\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      sameDocument: true,\n      // history.pushState/replaceState are always same-document\n      historyState: data,\n      state: undefined // No Navigation API state directly from history.pushState\n    });\n    const result = new InternalNavigationResult(this);\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      // Always false for pushState() or replaceState().\n      userInitiated: false,\n      hashChange\n    });\n    if (intercepted) {\n      return;\n    }\n    this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n  }\n  /** Equivalent to `navigation.traverseTo()`. */\n  traverseTo(key, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const entry = this.findEntry(key);\n    if (!entry) {\n      const domException = new DOMException('Invalid key', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    if (entry === this.currentEntry) {\n      return {\n        committed: Promise.resolve(this.currentEntry),\n        finished: Promise.resolve(this.currentEntry)\n      };\n    }\n    if (this.traversalQueue.has(entry.key)) {\n      const existingResult = this.traversalQueue.get(entry.key);\n      return {\n        committed: existingResult.committed,\n        finished: existingResult.finished\n      };\n    }\n    const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n    const destination = new FakeNavigationDestination({\n      url: entry.url,\n      state: entry.getState(),\n      historyState: entry.getHistoryState(),\n      key: entry.key,\n      id: entry.id,\n      index: entry.index,\n      sameDocument: entry.sameDocument\n    });\n    this.prospectiveEntryIndex = entry.index;\n    const result = new InternalNavigationResult(this);\n    this.traversalQueue.set(entry.key, result);\n    this.runTraversal(() => {\n      this.traversalQueue.delete(entry.key);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        // Always false for traverseTo().\n        userInitiated: false,\n        hashChange,\n        info: options?.info\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent);\n      }\n    });\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  /** Equivalent to `navigation.back()`. */\n  back(options) {\n    if (this.currentEntryIndex === 0) {\n      const domException = new DOMException('Cannot go back', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex - 1];\n    return this.traverseTo(entry.key, options);\n  }\n  /** Equivalent to `navigation.forward()`. */\n  forward(options) {\n    if (this.currentEntryIndex === this.entriesArr.length - 1) {\n      const domException = new DOMException('Cannot go forward', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex + 1];\n    return this.traverseTo(entry.key, options);\n  }\n  /**\n   * Equivalent to `history.go()`.\n   * Note that this method does not actually work precisely to how Chrome\n   * does, instead choosing a simpler model with less unexpected behavior.\n   * Chrome has a few edge case optimizations, for instance with repeated\n   * `back(); forward()` chains it collapses certain traversals.\n   */\n  go(direction) {\n    const targetIndex = this.prospectiveEntryIndex + direction;\n    if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n      return;\n    }\n    this.prospectiveEntryIndex = targetIndex;\n    this.runTraversal(() => {\n      // Check again that destination is in the entries array.\n      if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n        return;\n      }\n      const fromUrl = new URL(this.currentEntry.url);\n      const entry = this.entriesArr[targetIndex];\n      const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n      const destination = new FakeNavigationDestination({\n        url: entry.url,\n        state: entry.getState(),\n        historyState: entry.getHistoryState(),\n        key: entry.key,\n        id: entry.id,\n        index: entry.index,\n        sameDocument: entry.sameDocument\n      });\n      const result = new InternalNavigationResult(this);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        // Always false for go().\n        userInitiated: false,\n        hashChange\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent);\n      }\n    });\n  }\n  /** Runs a traversal synchronously or asynchronously */\n  runTraversal(traversal) {\n    if (this.synchronousTraversals) {\n      traversal();\n      return;\n    }\n    // Each traversal occupies a single timeout resolution.\n    // This means that Promises added to commit and finish should resolve\n    // before the next traversal.\n    this.nextTraversal = this.nextTraversal.then(() => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve();\n          traversal();\n        });\n      });\n    });\n  }\n  /** Equivalent to `navigation.addEventListener()`. */\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  /** Equivalent to `navigation.removeEventListener()`. */\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  /** Equivalent to `navigation.dispatchEvent()` */\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  /** Cleans up resources. */\n  dispose() {\n    // Recreate eventTarget to release current listeners.\n    this.eventTarget = this.createEventTarget();\n    this.disposed = true;\n  }\n  /** Returns whether this fake is disposed. */\n  isDisposed() {\n    return this.disposed;\n  }\n  abortOngoingNavigation(eventToAbort, reason) {\n    if (this.navigateEvent !== eventToAbort) {\n      return;\n    }\n    if (this.navigateEvent.abortController.signal.aborted) {\n      return;\n    }\n    const abortReason = reason ?? new DOMException('Navigation aborted', 'AbortError');\n    this.navigateEvent.cancel(abortReason);\n  }\n  /**\n   * Implementation for all navigations and traversals.\n   * @returns true if the event was intercepted, otherwise false\n   */\n  userAgentNavigate(destination, result, options) {\n    // The first navigation should disallow any future calls to set the initial\n    // entry.\n    this.canSetInitialEntry = false;\n    if (this.navigateEvent) {\n      this.abortOngoingNavigation(this.navigateEvent, new DOMException('Navigation superseded by a new navigation.', 'AbortError'));\n    }\n    // TODO(atscott): Disposing doesn't really do much because new requests are still processed\n    // if (this.disposed) {\n    //   return false;\n    // }\n    const dispatchResultIsTrueIfNoInterception = dispatchNavigateEvent({\n      navigationType: options.navigationType,\n      cancelable: options.cancelable,\n      canIntercept: options.canIntercept,\n      userInitiated: options.userInitiated,\n      hashChange: options.hashChange,\n      destination,\n      info: options.info,\n      sameDocument: destination.sameDocument,\n      result\n    });\n    return !dispatchResultIsTrueIfNoInterception;\n  }\n  /**\n   * Implementation for a push or replace navigation.\n   * https://whatpr.org/html/10919/browsing-the-web.html#url-and-history-update-steps\n   * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   * @internal\n   */\n  urlAndHistoryUpdateSteps(navigateEvent) {\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n  }\n  /**\n   * Implementation for a traverse navigation.\n   *\n   * https://whatpr.org/html/10919/browsing-the-web.html#apply-the-traverse-history-step\n   * ...\n   * > Let updateDocument be an algorithm step which performs update document for history step application given targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and previousEntry.\n   * > If targetEntry's document is equal to displayedDocument, then perform updateDocument.\n   * https://whatpr.org/html/10919/browsing-the-web.html#update-document-for-history-step-application\n   * which then goes to https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   * @internal\n   */\n  userAgentTraverse(navigateEvent) {\n    const oldUrl = this.currentEntry.url;\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    // Happens as part of \"updating the document\" steps https://whatpr.org/html/10919/browsing-the-web.html#updating-the-document\n    const popStateEvent = createPopStateEvent({\n      state: navigateEvent.destination.getHistoryState()\n    });\n    this._window.dispatchEvent(popStateEvent);\n    if (navigateEvent.hashChange) {\n      const hashchangeEvent = createHashChangeEvent(oldUrl, this.currentEntry.url);\n      this._window.dispatchEvent(hashchangeEvent);\n    }\n  }\n  /**\n   * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   * @internal\n   */\n  updateNavigationEntriesForSameDocumentNavigation({\n    destination,\n    navigationType,\n    result\n  }) {\n    const oldCurrentNHE = this.currentEntry;\n    const disposedNHEs = [];\n    if (navigationType === 'traverse') {\n      this.currentEntryIndex = destination.index;\n      if (this.currentEntryIndex === -1) {\n        throw new Error('unexpected current entry index');\n      }\n    } else if (navigationType === 'push') {\n      this.currentEntryIndex++;\n      this.prospectiveEntryIndex = this.currentEntryIndex; // prospectiveEntryIndex isn't in the spec but is an implementation detail\n      disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex));\n    } else if (navigationType === 'replace') {\n      disposedNHEs.push(oldCurrentNHE);\n    }\n    if (navigationType === 'push' || navigationType === 'replace') {\n      const index = this.currentEntryIndex;\n      const key = navigationType === 'push' ? String(this.nextKey++) : oldCurrentNHE?.key ?? String(this.nextKey++);\n      const newNHE = new FakeNavigationHistoryEntry(this.eventTarget, destination.url, {\n        id: String(this.nextId++),\n        key,\n        index,\n        sameDocument: true,\n        state: destination.getState(),\n        historyState: destination.getHistoryState()\n      });\n      this.entriesArr[this.currentEntryIndex] = newNHE;\n    }\n    result.committedResolve(this.currentEntry);\n    const currentEntryChangeEvent = createFakeNavigationCurrentEntryChangeEvent({\n      from: oldCurrentNHE,\n      navigationType: navigationType\n    });\n    this.eventTarget.dispatchEvent(currentEntryChangeEvent);\n    for (const disposedNHE of disposedNHEs) {\n      disposedNHE.dispose();\n    }\n  }\n  /** Utility method for finding entries with the given `key`. */\n  findEntry(key) {\n    for (const entry of this.entriesArr) {\n      if (entry.key === key) return entry;\n    }\n    return undefined;\n  }\n  set onnavigate(\n  // tslint:disable-next-line:no-any\n  _handler) {\n    throw new Error('unimplemented');\n  }\n  // tslint:disable-next-line:no-any\n  get onnavigate() {\n    throw new Error('unimplemented');\n  }\n  set oncurrententrychange(_handler) {\n    throw new Error('unimplemented');\n  }\n  get oncurrententrychange() {\n    throw new Error('unimplemented');\n  }\n  set onnavigatesuccess(\n  // tslint:disable-next-line:no-any\n  _handler) {\n    throw new Error('unimplemented');\n  }\n  // tslint:disable-next-line:no-any\n  get onnavigatesuccess() {\n    throw new Error('unimplemented');\n  }\n  set onnavigateerror(\n  // tslint:disable-next-line:no-any\n  _handler) {\n    throw new Error('unimplemented');\n  }\n  // tslint:disable-next-line:no-any\n  get onnavigateerror() {\n    throw new Error('unimplemented');\n  }\n  _transition = null;\n  /** @internal */\n  set transition(t) {\n    this._transition = t;\n  }\n  get transition() {\n    return this._transition;\n  }\n  updateCurrentEntry(_options) {\n    throw new Error('unimplemented');\n  }\n  reload(_options) {\n    throw new Error('unimplemented');\n  }\n}\n/**\n * Fake equivalent of `NavigationHistoryEntry`.\n */\nclass FakeNavigationHistoryEntry {\n  eventTarget;\n  url;\n  sameDocument;\n  id;\n  key;\n  index;\n  state;\n  historyState;\n  // tslint:disable-next-line:no-any\n  ondispose = null;\n  constructor(eventTarget, url, {\n    id,\n    key,\n    index,\n    sameDocument,\n    state,\n    historyState\n  }) {\n    this.eventTarget = eventTarget;\n    this.url = url;\n    this.id = id;\n    this.key = key;\n    this.index = index;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n  }\n  getState() {\n    // Budget copy.\n    return this.state ? JSON.parse(JSON.stringify(this.state)) : this.state;\n  }\n  getHistoryState() {\n    // Budget copy.\n    return this.historyState ? JSON.parse(JSON.stringify(this.historyState)) : this.historyState;\n  }\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  /** internal */\n  dispose() {\n    const disposeEvent = new Event('disposed');\n    this.dispatchEvent(disposeEvent);\n    // release current listeners\n    this.eventTarget = null;\n  }\n}\n/**\n * Create a fake equivalent of `NavigateEvent`. This is not a class because ES5\n * transpiled JavaScript cannot extend native Event.\n *\n * https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing\n */\nfunction dispatchNavigateEvent({\n  cancelable,\n  canIntercept,\n  userInitiated,\n  hashChange,\n  navigationType,\n  destination,\n  info,\n  sameDocument,\n  result\n}) {\n  const {\n    navigation\n  } = result;\n  const eventAbortController = new AbortController();\n  const event = new Event('navigate', {\n    bubbles: false,\n    cancelable\n  });\n  event.navigationType = navigationType;\n  event.destination = destination;\n  event.canIntercept = canIntercept;\n  event.userInitiated = userInitiated;\n  event.hashChange = hashChange;\n  event.signal = eventAbortController.signal;\n  event.abortController = eventAbortController;\n  event.info = info;\n  event.focusResetBehavior = null;\n  event.scrollBehavior = null;\n  event.interceptionState = 'none';\n  event.downloadRequest = null;\n  event.formData = null;\n  event.result = result;\n  event.sameDocument = sameDocument;\n  let precommitHandlers = [];\n  let handlers = [];\n  // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigateevent-intercept\n  event.intercept = function (options) {\n    if (!this.canIntercept) {\n      throw new DOMException(`Cannot intercept when canIntercept is 'false'`, 'SecurityError');\n    }\n    this.interceptionState = 'intercepted';\n    event.sameDocument = true;\n    const precommitHandler = options?.precommitHandler;\n    if (precommitHandler) {\n      if (!this.cancelable) {\n        throw new DOMException(`Cannot use precommitHandler when cancelable is 'false'`, 'InvalidStateError');\n      }\n      precommitHandlers.push(precommitHandler);\n    }\n    if (event.interceptionState !== 'none' && event.interceptionState !== 'intercepted') {\n      throw new Error('Event interceptionState should be \"none\" or \"intercepted\"');\n    }\n    event.interceptionState = 'intercepted';\n    const handler = options?.handler;\n    if (handler) {\n      handlers.push(handler);\n    }\n    // override old options with new ones. UA _may_ report a console warning if new options differ from previous\n    event.focusResetBehavior = options?.focusReset ?? event.focusResetBehavior;\n    event.scrollBehavior = options?.scroll ?? event.scrollBehavior;\n  };\n  // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigateevent-scroll\n  event.scroll = function () {\n    if (event.interceptionState !== 'committed') {\n      throw new DOMException(`Failed to execute 'scroll' on 'NavigateEvent': scroll() must be ` + `called after commit() and interception options must specify manual scroll.`, 'InvalidStateError');\n    }\n    processScrollBehavior(event);\n  };\n  // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigationprecommitcontroller-redirect\n  function redirect(url, options = {}) {\n    if (event.interceptionState === 'none') {\n      throw new Error('cannot redirect when event is not intercepted');\n    }\n    if (event.interceptionState !== 'intercepted') {\n      throw new DOMException(`cannot redirect when event is not in 'intercepted' state`, 'InvalidStateError');\n    }\n    if (event.navigationType !== 'push' && event.navigationType !== 'replace') {\n      throw new DOMException(`cannot redirect when navigationType is not 'push' or 'replace`, 'InvalidStateError');\n    }\n    const destinationUrl = new URL(url, navigation.currentEntry.url);\n    if (options.history === 'push' || options.history === 'replace') {\n      event.navigationType = options.history;\n    }\n    if (options.hasOwnProperty('state')) {\n      event.destination.state = options.state;\n    }\n    event.destination.url = destinationUrl.href;\n    if (options.hasOwnProperty('info')) {\n      event.info = options.info;\n    }\n  }\n  // https://whatpr.org/html/10919/nav-history-apis.html#inner-navigate-event-firing-algorithm\n  // \"Let commit be the following steps:\"\n  function commit() {\n    if (result.signal.aborted) {\n      return;\n    }\n    navigation.transition?.committedResolve();\n    if (event.interceptionState === 'intercepted') {\n      event.interceptionState = 'committed';\n      switch (event.navigationType) {\n        case 'push':\n        case 'replace':\n          {\n            navigation.urlAndHistoryUpdateSteps(event);\n            break;\n          }\n        case 'reload':\n          {\n            navigation.updateNavigationEntriesForSameDocumentNavigation(event);\n            break;\n          }\n        case 'traverse':\n          {\n            navigation.userAgentTraverse(event);\n            break;\n          }\n      }\n    }\n    const promisesList = handlers.map(handler => handler());\n    if (promisesList.length === 0) {\n      promisesList.push(Promise.resolve());\n    }\n    Promise.all(promisesList).then(() => {\n      // Follows steps outlined under \"Wait for all of promisesList, with the following success steps:\"\n      // in the spec https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing.\n      if (result.signal.aborted) {\n        return;\n      }\n      if (event !== navigation.navigateEvent) {\n        if (!result.signal.aborted && result.committedTo) {\n          result.finishedReject(new DOMException('Navigation superseded before handler completion', 'AbortError'));\n        }\n        return;\n      }\n      navigation.navigateEvent = null;\n      finishNavigationEvent(event, true);\n      const navigatesuccessEvent = new Event('navigatesuccess', {\n        bubbles: false,\n        cancelable: false\n      });\n      navigation.eventTarget.dispatchEvent(navigatesuccessEvent);\n      result.finishedResolve();\n      navigation.transition?.finishedResolve();\n      navigation.transition = null;\n    }).catch(reason => {\n      if (!event.abortController.signal.aborted) {\n        event.cancel(reason);\n      }\n    });\n  }\n  // Internal only.\n  // https://whatpr.org/html/10919/nav-history-apis.html#inner-navigate-event-firing-algorithm\n  // \"Let cancel be the following steps given reason\"\n  event.cancel = function (reason) {\n    if (result.signal.aborted) {\n      return;\n    }\n    this.abortController.abort(reason);\n    const isCurrentGlobalNavigationEvent = this === navigation.navigateEvent;\n    if (isCurrentGlobalNavigationEvent) {\n      navigation.navigateEvent = null;\n    }\n    if (this.interceptionState !== 'intercepted' && this.interceptionState !== 'finished') {\n      finishNavigationEvent(this, false);\n    } else if (this.interceptionState === 'intercepted') {\n      this.interceptionState = 'finished';\n    }\n    const navigateerrorEvent = new Event('navigateerror', {\n      bubbles: false,\n      cancelable\n    });\n    navigateerrorEvent.error = reason;\n    navigation.eventTarget.dispatchEvent(navigateerrorEvent);\n    if (result.committedTo === null && !result.signal.aborted) {\n      result.committedReject(reason);\n    }\n    result.finishedReject(reason);\n    const transition = navigation.transition;\n    transition?.committedReject(reason);\n    transition?.finishedReject(reason);\n    navigation.transition = null;\n  };\n  function dispatch() {\n    navigation.navigateEvent = event;\n    const dispatchResult = navigation.eventTarget.dispatchEvent(event);\n    if (event.interceptionState === 'intercepted') {\n      if (!navigation.currentEntry) {\n        event.cancel(new DOMException('Cannot create transition without a currentEntry for intercepted navigation.', 'InvalidStateError'));\n        return;\n      }\n      const transition = new InternalNavigationTransition(navigation.currentEntry, navigationType);\n      navigation.transition = transition;\n      // Mark transition.finished as handled (Spec Step 33.4)\n      transition.finished.catch(() => {});\n      transition.committed.catch(() => {});\n    }\n    if (!dispatchResult && event.cancelable) {\n      if (!event.abortController.signal.aborted) {\n        event.cancel(new DOMException('Navigation prevented by event.preventDefault()', 'AbortError'));\n      }\n    } else {\n      if (precommitHandlers.length === 0) {\n        commit();\n      } else {\n        const precommitController = {\n          redirect\n        };\n        const precommitPromisesList = precommitHandlers.map(handler => {\n          let p;\n          try {\n            p = handler(precommitController);\n          } catch (e) {\n            p = Promise.reject(e);\n          }\n          p.catch(() => {});\n          return p;\n        });\n        Promise.all(precommitPromisesList).then(() => commit()).catch(reason => {\n          if (event.abortController.signal.aborted) {\n            return;\n          }\n          if (navigation.transition) {\n            navigation.transition.committedReject(reason);\n          }\n          event.cancel(reason);\n        });\n      }\n    }\n  }\n  dispatch();\n  return event.interceptionState === 'none';\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#navigateevent-finish */\nfunction finishNavigationEvent(event, didFulfill) {\n  if (event.interceptionState === 'finished') {\n    throw new Error('Attempting to finish navigation event that was already finished');\n  }\n  if (event.interceptionState === 'intercepted') {\n    if (didFulfill === true) {\n      throw new Error('didFulfill should be false');\n    }\n    event.interceptionState = 'finished';\n    return;\n  }\n  if (event.interceptionState === 'none') {\n    return;\n  }\n  potentiallyResetFocus(event);\n  if (didFulfill) {\n    potentiallyResetScroll(event);\n  }\n  event.interceptionState = 'finished';\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#potentially-reset-the-focus */\nfunction potentiallyResetFocus(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset focus if navigation event is not committed or scrolled');\n  }\n  if (event.focusResetBehavior === 'manual') {\n    return;\n  }\n  // TODO(atscott): the rest of the steps\n}\nfunction potentiallyResetScroll(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset scroll if navigation event is not committed or scrolled');\n  }\n  if (event.interceptionState === 'scrolled' || event.scrollBehavior === 'manual') {\n    return;\n  }\n  processScrollBehavior(event);\n}\n/* https://whatpr.org/html/10919/nav-history-apis.html#process-scroll-behavior */\nfunction processScrollBehavior(event) {\n  if (event.interceptionState !== 'committed') {\n    throw new Error('invalid event interception state when processing scroll behavior');\n  }\n  event.interceptionState = 'scrolled';\n  // TODO(atscott): the rest of the steps\n}\n/**\n * Create a fake equivalent of `NavigationCurrentEntryChange`. This does not use\n * a class because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createFakeNavigationCurrentEntryChangeEvent({\n  from,\n  navigationType\n}) {\n  const event = new Event('currententrychange', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.from = from;\n  event.navigationType = navigationType;\n  return event;\n}\n/**\n * Create a fake equivalent of `PopStateEvent`. This does not use a class\n * because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createPopStateEvent({\n  state\n}) {\n  const event = new Event('popstate', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.state = state;\n  return event;\n}\nfunction createHashChangeEvent(newURL, oldURL) {\n  const event = new Event('hashchange', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.newURL = newURL;\n  event.oldURL = oldURL;\n  return event;\n}\n/**\n * Fake equivalent of `NavigationDestination`.\n */\nclass FakeNavigationDestination {\n  url;\n  sameDocument;\n  key;\n  id;\n  index;\n  state;\n  historyState;\n  constructor({\n    url,\n    sameDocument,\n    historyState,\n    state,\n    key = null,\n    id = null,\n    index = -1\n  }) {\n    this.url = url;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n    this.key = key;\n    this.id = id;\n    this.index = index;\n  }\n  getState() {\n    return this.state;\n  }\n  getHistoryState() {\n    return this.historyState;\n  }\n}\n/** Utility function to determine whether two UrlLike have the same hash. */\nfunction isHashChange(from, to) {\n  return to.hash !== from.hash && to.hostname === from.hostname && to.pathname === from.pathname && to.search === from.search;\n}\nclass InternalNavigationTransition {\n  from;\n  navigationType;\n  finished;\n  committed;\n  finishedResolve;\n  finishedReject;\n  committedResolve;\n  committedReject;\n  constructor(from, navigationType) {\n    this.from = from;\n    this.navigationType = navigationType;\n    this.finished = new Promise((resolve, reject) => {\n      this.finishedReject = reject;\n      this.finishedResolve = resolve;\n    });\n    this.committed = new Promise((resolve, reject) => {\n      this.committedReject = reject;\n      this.committedResolve = resolve;\n    });\n    // All rejections are handled.\n    this.finished.catch(() => {});\n    this.committed.catch(() => {});\n  }\n}\n/**\n * Internal utility class for representing the result of a navigation.\n * Generally equivalent to the \"apiMethodTracker\" in the spec.\n */\nclass InternalNavigationResult {\n  navigation;\n  committedTo = null;\n  committedResolve;\n  committedReject;\n  finishedResolve;\n  finishedReject;\n  committed;\n  finished;\n  get signal() {\n    return this.abortController.signal;\n  }\n  abortController = /*#__PURE__*/new AbortController();\n  constructor(navigation) {\n    this.navigation = navigation;\n    this.committed = new Promise((resolve, reject) => {\n      this.committedResolve = entry => {\n        this.committedTo = entry;\n        resolve(entry);\n      };\n      this.committedReject = reject;\n    });\n    this.finished = new Promise((resolve, reject) => {\n      this.finishedResolve = () => {\n        if (this.committedTo === null) {\n          throw new Error('NavigateEvent should have been committed before resolving finished promise.');\n        }\n        resolve(this.committedTo);\n      };\n      this.finishedReject = reason => {\n        reject(reason);\n        this.abortController.abort(reason);\n      };\n    });\n    // All rejections are handled.\n    this.committed.catch(() => {});\n    this.finished.catch(() => {});\n  }\n}\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(/*#__PURE__*/getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(/*#__PURE__*/getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    const testBed = TestBedImpl.INSTANCE;\n    if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      testBed.resetTestingModule();\n      resetFakeAsyncZoneIfExists();\n    }\n  };\n}\nlet Log = /*#__PURE__*/(() => {\n  class Log {\n    logItems;\n    constructor() {\n      this.logItems = [];\n    }\n    add(value) {\n      this.logItems.push(value);\n    }\n    fn(value) {\n      return () => {\n        this.logItems.push(value);\n      };\n    }\n    clear() {\n      this.logItems = [];\n    }\n    result() {\n      return this.logItems.join('; ');\n    }\n    static ɵfac = function Log_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Log)();\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: Log,\n      factory: Log.ɵfac\n    });\n  }\n  return Log;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockBehavior, DeferBlockFixture, DeferBlockState, InjectSetupWrapper, TestBed, TestComponentRenderer, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, FakeNavigation as ɵFakeNavigation, Log as ɵLog, MetadataOverrider as ɵMetadataOverrider, getCleanupHook as ɵgetCleanupHook };\n//# sourceMappingURL=testing.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}