{"ast":null,"code":"/**\r\n * @license Angular v20.1.7\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport * as i0 from '@angular/core';\nimport { inject, Injectable, InjectionToken, DOCUMENT, Optional, Inject, ɵɵinject as __inject } from '@angular/core';\nimport { Subject } from 'rxjs';\nlet _DOM = null;\nfunction getDOM() {\n  return _DOM;\n}\nfunction setRootDomAdapter(adapter) {\n  _DOM ??= adapter;\n}\n/**\r\n * Provides DOM operations in an environment-agnostic way.\r\n *\r\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\r\n * can introduce XSS risks.\r\n */\nclass DomAdapter {}\n\n/**\r\n * This class should not be used directly by an application developer. Instead, use\r\n * {@link Location}.\r\n *\r\n * `PlatformLocation` encapsulates all calls to DOM APIs, which allows the Router to be\r\n * platform-agnostic.\r\n * This means that we can have different implementation of `PlatformLocation` for the different\r\n * platforms that Angular supports. For example, `@angular/platform-browser` provides an\r\n * implementation specific to the browser environment, while `@angular/platform-server` provides\r\n * one suitable for use with server-side rendering.\r\n *\r\n * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}\r\n * when they need to interact with the DOM APIs like pushState, popState, etc.\r\n *\r\n * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly\r\n * by the {@link /api/router/Router Router} in order to navigate between routes. Since all interactions between\r\n * {@link /api/router/Router Router} /\r\n * {@link Location} / {@link LocationStrategy} and DOM APIs flow through the `PlatformLocation`\r\n * class, they are all platform-agnostic.\r\n *\r\n * @publicApi\r\n */\nlet PlatformLocation = /*#__PURE__*/(() => {\n  class PlatformLocation {\n    historyGo(relativePosition) {\n      throw new Error(ngDevMode ? 'Not implemented' : '');\n    }\n    static ɵfac = function PlatformLocation_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PlatformLocation)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PlatformLocation,\n      factory: () => (() => inject(BrowserPlatformLocation))(),\n      providedIn: 'platform'\n    });\n  }\n  return PlatformLocation;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * @description\r\n * Indicates when a location is initialized.\r\n *\r\n * @publicApi\r\n */\nconst LOCATION_INITIALIZED = /*#__PURE__*/new InjectionToken(ngDevMode ? 'Location Initialized' : '');\n/**\r\n * `PlatformLocation` encapsulates all of the direct calls to platform APIs.\r\n * This class should not be used directly by an application developer. Instead, use\r\n * {@link Location}.\r\n *\r\n * @publicApi\r\n */\nlet BrowserPlatformLocation = /*#__PURE__*/(() => {\n  class BrowserPlatformLocation extends PlatformLocation {\n    _location;\n    _history;\n    _doc = inject(DOCUMENT);\n    constructor() {\n      super();\n      this._location = window.location;\n      this._history = window.history;\n    }\n    getBaseHrefFromDOM() {\n      return getDOM().getBaseHref(this._doc);\n    }\n    onPopState(fn) {\n      const window = getDOM().getGlobalEventTarget(this._doc, 'window');\n      window.addEventListener('popstate', fn, false);\n      return () => window.removeEventListener('popstate', fn);\n    }\n    onHashChange(fn) {\n      const window = getDOM().getGlobalEventTarget(this._doc, 'window');\n      window.addEventListener('hashchange', fn, false);\n      return () => window.removeEventListener('hashchange', fn);\n    }\n    get href() {\n      return this._location.href;\n    }\n    get protocol() {\n      return this._location.protocol;\n    }\n    get hostname() {\n      return this._location.hostname;\n    }\n    get port() {\n      return this._location.port;\n    }\n    get pathname() {\n      return this._location.pathname;\n    }\n    get search() {\n      return this._location.search;\n    }\n    get hash() {\n      return this._location.hash;\n    }\n    set pathname(newPath) {\n      this._location.pathname = newPath;\n    }\n    pushState(state, title, url) {\n      this._history.pushState(state, title, url);\n    }\n    replaceState(state, title, url) {\n      this._history.replaceState(state, title, url);\n    }\n    forward() {\n      this._history.forward();\n    }\n    back() {\n      this._history.back();\n    }\n    historyGo(relativePosition = 0) {\n      this._history.go(relativePosition);\n    }\n    getState() {\n      return this._history.state;\n    }\n    static ɵfac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BrowserPlatformLocation)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: BrowserPlatformLocation,\n      factory: () => (() => new BrowserPlatformLocation())(),\n      providedIn: 'platform'\n    });\n  }\n  return BrowserPlatformLocation;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * Joins two parts of a URL with a slash if needed.\r\n *\r\n * @param start  URL string\r\n * @param end    URL string\r\n *\r\n *\r\n * @returns The joined URL string.\r\n */\nfunction joinWithSlash(start, end) {\n  // If `start` is an empty string, return `end` as the result.\n  if (!start) return end;\n  // If `end` is an empty string, return `start` as the result.\n  if (!end) return start;\n  // If `start` ends with a slash, remove the leading slash from `end`.\n  if (start.endsWith('/')) {\n    return end.startsWith('/') ? start + end.slice(1) : start + end;\n  }\n  // If `start` doesn't end with a slash, add one if `end` doesn't start with a slash.\n  return end.startsWith('/') ? start + end : `${start}/${end}`;\n}\n/**\r\n * Removes a trailing slash from a URL string if needed.\r\n * Looks for the first occurrence of either `#`, `?`, or the end of the\r\n * line as `/` characters and removes the trailing slash if one exists.\r\n *\r\n * @param url URL string.\r\n *\r\n * @returns The URL string, modified if needed.\r\n */\nfunction stripTrailingSlash(url) {\n  // Find the index of the first occurrence of `#`, `?`, or the end of the string.\n  // This marks the start of the query string, fragment, or the end of the URL path.\n  const pathEndIdx = url.search(/#|\\?|$/);\n  // Check if the character before `pathEndIdx` is a trailing slash.\n  // If it is, remove the trailing slash and return the modified URL.\n  // Otherwise, return the URL as is.\n  return url[pathEndIdx - 1] === '/' ? url.slice(0, pathEndIdx - 1) + url.slice(pathEndIdx) : url;\n}\n/**\r\n * Normalizes URL parameters by prepending with `?` if needed.\r\n *\r\n * @param  params String of URL parameters.\r\n *\r\n * @returns The normalized URL parameters string.\r\n */\nfunction normalizeQueryParams(params) {\n  return params && params[0] !== '?' ? `?${params}` : params;\n}\n\n/**\r\n * Enables the `Location` service to read route state from the browser's URL.\r\n * Angular provides two strategies:\r\n * `HashLocationStrategy` and `PathLocationStrategy`.\r\n *\r\n * Applications should use the `Router` or `Location` services to\r\n * interact with application route state.\r\n *\r\n * For instance, `HashLocationStrategy` produces URLs like\r\n * <code class=\"no-auto-link\">http://example.com/#/foo</code>,\r\n * and `PathLocationStrategy` produces\r\n * <code class=\"no-auto-link\">http://example.com/foo</code> as an equivalent URL.\r\n *\r\n * See these two classes for more.\r\n *\r\n * @publicApi\r\n */\nlet LocationStrategy = /*#__PURE__*/(() => {\n  class LocationStrategy {\n    historyGo(relativePosition) {\n      throw new Error(ngDevMode ? 'Not implemented' : '');\n    }\n    static ɵfac = function LocationStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || LocationStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LocationStrategy,\n      factory: () => (() => inject(PathLocationStrategy))(),\n      providedIn: 'root'\n    });\n  }\n  return LocationStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * A predefined DI token for the base href\r\n * to be used with the `PathLocationStrategy`.\r\n * The base href is the URL prefix that should be preserved when generating\r\n * and recognizing URLs.\r\n *\r\n * @usageNotes\r\n *\r\n * The following example shows how to use this token to configure the root app injector\r\n * with a base href value, so that the DI framework can supply the dependency anywhere in the app.\r\n *\r\n * ```ts\r\n * import {NgModule} from '@angular/core';\r\n * import {APP_BASE_HREF} from '@angular/common';\r\n *\r\n * @NgModule({\r\n *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * @publicApi\r\n */\nconst APP_BASE_HREF = /*#__PURE__*/new InjectionToken(ngDevMode ? 'appBaseHref' : '');\n/**\r\n * @description\r\n * A {@link LocationStrategy} used to configure the {@link Location} service to\r\n * represent its state in the\r\n * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the\r\n * browser's URL.\r\n *\r\n * If you're using `PathLocationStrategy`, you may provide a {@link APP_BASE_HREF}\r\n * or add a `<base href>` element to the document to override the default.\r\n *\r\n * For instance, if you provide an `APP_BASE_HREF` of `'/my/app/'` and call\r\n * `location.go('/foo')`, the browser's URL will become\r\n * `example.com/my/app/foo`. To ensure all relative URIs resolve correctly,\r\n * the `<base href>` and/or `APP_BASE_HREF` should end with a `/`.\r\n *\r\n * Similarly, if you add `<base href='/my/app/'/>` to the document and call\r\n * `location.go('/foo')`, the browser's URL will become\r\n * `example.com/my/app/foo`.\r\n *\r\n * Note that when using `PathLocationStrategy`, neither the query nor\r\n * the fragment in the `<base href>` will be preserved, as outlined\r\n * by the [RFC](https://tools.ietf.org/html/rfc3986#section-5.2.2).\r\n *\r\n * @usageNotes\r\n *\r\n * ### Example\r\n *\r\n * {@example common/location/ts/path_location_component.ts region='LocationComponent'}\r\n *\r\n * @publicApi\r\n */\nlet PathLocationStrategy = /*#__PURE__*/(() => {\n  class PathLocationStrategy extends LocationStrategy {\n    _platformLocation;\n    _baseHref;\n    _removeListenerFns = [];\n    constructor(_platformLocation, href) {\n      super();\n      this._platformLocation = _platformLocation;\n      this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject(DOCUMENT).location?.origin ?? '';\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n      while (this._removeListenerFns.length) {\n        this._removeListenerFns.pop()();\n      }\n    }\n    onPopState(fn) {\n      this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));\n    }\n    getBaseHref() {\n      return this._baseHref;\n    }\n    prepareExternalUrl(internal) {\n      return joinWithSlash(this._baseHref, internal);\n    }\n    path(includeHash = false) {\n      const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);\n      const hash = this._platformLocation.hash;\n      return hash && includeHash ? `${pathname}${hash}` : pathname;\n    }\n    pushState(state, title, url, queryParams) {\n      const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));\n      this._platformLocation.pushState(state, title, externalUrl);\n    }\n    replaceState(state, title, url, queryParams) {\n      const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));\n      this._platformLocation.replaceState(state, title, externalUrl);\n    }\n    forward() {\n      this._platformLocation.forward();\n    }\n    back() {\n      this._platformLocation.back();\n    }\n    getState() {\n      return this._platformLocation.getState();\n    }\n    historyGo(relativePosition = 0) {\n      this._platformLocation.historyGo?.(relativePosition);\n    }\n    static ɵfac = function PathLocationStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PathLocationStrategy)(i0.ɵɵinject(PlatformLocation), i0.ɵɵinject(APP_BASE_HREF, 8));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PathLocationStrategy,\n      factory: PathLocationStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PathLocationStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * @description\r\n *\r\n * A service that applications can use to interact with a browser's URL.\r\n *\r\n * Depending on the `LocationStrategy` used, `Location` persists\r\n * to the URL's path or the URL's hash segment.\r\n *\r\n * @usageNotes\r\n *\r\n * It's better to use the `Router.navigate()` service to trigger route changes. Use\r\n * `Location` only if you need to interact with or create normalized URLs outside of\r\n * routing.\r\n *\r\n * `Location` is responsible for normalizing the URL against the application's base href.\r\n * A normalized URL is absolute from the URL host, includes the application's base href, and has no\r\n * trailing slash:\r\n * - `/my/app/user/123` is normalized\r\n * - `my/app/user/123` **is not** normalized\r\n * - `/my/app/user/123/` **is not** normalized\r\n *\r\n * ### Example\r\n *\r\n * {@example common/location/ts/path_location_component.ts region='LocationComponent'}\r\n *\r\n * @publicApi\r\n */\nlet Location = /*#__PURE__*/(() => {\n  class Location {\n    /** @internal */\n    _subject = new Subject();\n    /** @internal */\n    _basePath;\n    /** @internal */\n    _locationStrategy;\n    /** @internal */\n    _urlChangeListeners = [];\n    /** @internal */\n    _urlChangeSubscription = null;\n    constructor(locationStrategy) {\n      this._locationStrategy = locationStrategy;\n      const baseHref = this._locationStrategy.getBaseHref();\n      // Note: This class's interaction with base HREF does not fully follow the rules\n      // outlined in the spec https://www.freesoft.org/CIE/RFC/1808/18.htm.\n      // Instead of trying to fix individual bugs with more and more code, we should\n      // investigate using the URL constructor and providing the base as a second\n      // argument.\n      // https://developer.mozilla.org/en-US/docs/Web/API/URL/URL#parameters\n      this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));\n      this._locationStrategy.onPopState(ev => {\n        this._subject.next({\n          'url': this.path(true),\n          'pop': true,\n          'state': ev.state,\n          'type': ev.type\n        });\n      });\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n      this._urlChangeSubscription?.unsubscribe();\n      this._urlChangeListeners = [];\n    }\n    /**\r\n     * Normalizes the URL path for this location.\r\n     *\r\n     * @param includeHash True to include an anchor fragment in the path.\r\n     *\r\n     * @returns The normalized URL path.\r\n     */\n    // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is\n    // removed.\n    path(includeHash = false) {\n      return this.normalize(this._locationStrategy.path(includeHash));\n    }\n    /**\r\n     * Reports the current state of the location history.\r\n     * @returns The current value of the `history.state` object.\r\n     */\n    getState() {\n      return this._locationStrategy.getState();\n    }\n    /**\r\n     * Normalizes the given path and compares to the current normalized path.\r\n     *\r\n     * @param path The given URL path.\r\n     * @param query Query parameters.\r\n     *\r\n     * @returns True if the given URL path is equal to the current normalized path, false\r\n     * otherwise.\r\n     */\n    isCurrentPathEqualTo(path, query = '') {\n      return this.path() == this.normalize(path + normalizeQueryParams(query));\n    }\n    /**\r\n     * Normalizes a URL path by stripping any trailing slashes.\r\n     *\r\n     * @param url String representing a URL.\r\n     *\r\n     * @returns The normalized URL string.\r\n     */\n    normalize(url) {\n      return Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));\n    }\n    /**\r\n     * Normalizes an external URL path.\r\n     * If the given URL doesn't begin with a leading slash (`'/'`), adds one\r\n     * before normalizing. Adds a hash if `HashLocationStrategy` is\r\n     * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.\r\n     *\r\n     * @param url String representing a URL.\r\n     *\r\n     * @returns  A normalized platform-specific URL.\r\n     */\n    prepareExternalUrl(url) {\n      if (url && url[0] !== '/') {\n        url = '/' + url;\n      }\n      return this._locationStrategy.prepareExternalUrl(url);\n    }\n    // TODO: rename this method to pushState\n    /**\r\n     * Changes the browser's URL to a normalized version of a given URL, and pushes a\r\n     * new item onto the platform's history.\r\n     *\r\n     * @param path  URL path to normalize.\r\n     * @param query Query parameters.\r\n     * @param state Location history state.\r\n     *\r\n     */\n    go(path, query = '', state = null) {\n      this._locationStrategy.pushState(state, '', path, query);\n      this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);\n    }\n    /**\r\n     * Changes the browser's URL to a normalized version of the given URL, and replaces\r\n     * the top item on the platform's history stack.\r\n     *\r\n     * @param path  URL path to normalize.\r\n     * @param query Query parameters.\r\n     * @param state Location history state.\r\n     */\n    replaceState(path, query = '', state = null) {\n      this._locationStrategy.replaceState(state, '', path, query);\n      this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);\n    }\n    /**\r\n     * Navigates forward in the platform's history.\r\n     */\n    forward() {\n      this._locationStrategy.forward();\n    }\n    /**\r\n     * Navigates back in the platform's history.\r\n     */\n    back() {\n      this._locationStrategy.back();\n    }\n    /**\r\n     * Navigate to a specific page from session history, identified by its relative position to the\r\n     * current page.\r\n     *\r\n     * @param relativePosition  Position of the target page in the history relative to the current\r\n     *     page.\r\n     * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`\r\n     * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go\r\n     * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs\r\n     * when `relativePosition` equals 0.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history\r\n     */\n    historyGo(relativePosition = 0) {\n      this._locationStrategy.historyGo?.(relativePosition);\n    }\n    /**\r\n     * Registers a URL change listener. Use to catch updates performed by the Angular\r\n     * framework that are not detectible through \"popstate\" or \"hashchange\" events.\r\n     *\r\n     * @param fn The change handler function, which take a URL and a location history state.\r\n     * @returns A function that, when executed, unregisters a URL change listener.\r\n     */\n    onUrlChange(fn) {\n      this._urlChangeListeners.push(fn);\n      this._urlChangeSubscription ??= this.subscribe(v => {\n        this._notifyUrlChangeListeners(v.url, v.state);\n      });\n      return () => {\n        const fnIndex = this._urlChangeListeners.indexOf(fn);\n        this._urlChangeListeners.splice(fnIndex, 1);\n        if (this._urlChangeListeners.length === 0) {\n          this._urlChangeSubscription?.unsubscribe();\n          this._urlChangeSubscription = null;\n        }\n      };\n    }\n    /** @internal */\n    _notifyUrlChangeListeners(url = '', state) {\n      this._urlChangeListeners.forEach(fn => fn(url, state));\n    }\n    /**\r\n     * Subscribes to the platform's `popState` events.\r\n     *\r\n     * Note: `Location.go()` does not trigger the `popState` event in the browser. Use\r\n     * `Location.onUrlChange()` to subscribe to URL changes instead.\r\n     *\r\n     * @param value Event that is triggered when the state history changes.\r\n     * @param exception The exception to throw.\r\n     *\r\n     * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)\r\n     *\r\n     * @returns Subscribed events.\r\n     */\n    subscribe(onNext, onThrow, onReturn) {\n      return this._subject.subscribe({\n        next: onNext,\n        error: onThrow ?? undefined,\n        complete: onReturn ?? undefined\n      });\n    }\n    /**\r\n     * Normalizes URL parameters by prepending with `?` if needed.\r\n     *\r\n     * @param  params String of URL parameters.\r\n     *\r\n     * @returns The normalized URL parameters string.\r\n     */\n    static normalizeQueryParams = normalizeQueryParams;\n    /**\r\n     * Joins two parts of a URL with a slash if needed.\r\n     *\r\n     * @param start  URL string\r\n     * @param end    URL string\r\n     *\r\n     *\r\n     * @returns The joined URL string.\r\n     */\n    static joinWithSlash = joinWithSlash;\n    /**\r\n     * Removes a trailing slash from a URL string if needed.\r\n     * Looks for the first occurrence of either `#`, `?`, or the end of the\r\n     * line as `/` characters and removes the trailing slash if one exists.\r\n     *\r\n     * @param url URL string.\r\n     *\r\n     * @returns The URL string, modified if needed.\r\n     */\n    static stripTrailingSlash = stripTrailingSlash;\n    static ɵfac = function Location_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Location)(i0.ɵɵinject(LocationStrategy));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Location,\n      factory: () => createLocation(),\n      providedIn: 'root'\n    });\n  }\n  return Location;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction createLocation() {\n  return new Location(__inject(LocationStrategy));\n}\nfunction _stripBasePath(basePath, url) {\n  if (!basePath || !url.startsWith(basePath)) {\n    return url;\n  }\n  const strippedUrl = url.substring(basePath.length);\n  if (strippedUrl === '' || ['/', ';', '?', '#'].includes(strippedUrl[0])) {\n    return strippedUrl;\n  }\n  return url;\n}\nfunction _stripIndexHtml(url) {\n  return url.replace(/\\/index.html$/, '');\n}\nfunction _stripOrigin(baseHref) {\n  // DO NOT REFACTOR! Previously, this check looked like this:\n  // `/^(https?:)?\\/\\//.test(baseHref)`, but that resulted in\n  // syntactically incorrect code after Closure Compiler minification.\n  // This was likely caused by a bug in Closure Compiler, but\n  // for now, the check is rewritten to use `new RegExp` instead.\n  const isAbsoluteUrl = new RegExp('^(https?:)?//').test(baseHref);\n  if (isAbsoluteUrl) {\n    const [, pathname] = baseHref.split(/\\/\\/[^\\/]+/);\n    return pathname;\n  }\n  return baseHref;\n}\nexport { APP_BASE_HREF, BrowserPlatformLocation, DomAdapter, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation, getDOM, joinWithSlash, normalizeQueryParams, setRootDomAdapter };\n//# sourceMappingURL=location.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}