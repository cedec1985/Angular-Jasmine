{"ast":null,"code":"/**\n * @license Angular v20.2.1\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ɵnormalizeQueryParams as _normalizeQueryParams, LocationStrategy } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Optional, inject, DOCUMENT } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { PlatformNavigation } from './platform_navigation.mjs';\nimport { ɵFakeNavigation as _FakeNavigation } from '@angular/core/testing';\nexport { ɵFakeNavigation } from '@angular/core/testing';\nimport { PlatformLocation, Location, LocationStrategy as LocationStrategy$1 } from './location.mjs';\n\n/**\n * Parser from https://tools.ietf.org/html/rfc3986#appendix-B\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n *\n * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related\n *\n * Results in:\n *\n * $1 = http:\n * $2 = http\n * $3 = //www.ics.uci.edu\n * $4 = www.ics.uci.edu\n * $5 = /pub/ietf/uri/\n * $6 = <undefined>\n * $7 = <undefined>\n * $8 = #Related\n * $9 = Related\n */\nconst urlParse = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nfunction parseUrl(urlStr, baseHref) {\n  const verifyProtocol = /^((http[s]?|ftp):\\/\\/)/;\n  let serverBase;\n  // URL class requires full URL. If the URL string doesn't start with protocol, we need to add\n  // an arbitrary base URL which can be removed afterward.\n  if (!verifyProtocol.test(urlStr)) {\n    serverBase = 'http://empty.com/';\n  }\n  let parsedUrl;\n  try {\n    parsedUrl = new URL(urlStr, serverBase);\n  } catch (e) {\n    const result = urlParse.exec(serverBase || '' + urlStr);\n    if (!result) {\n      throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);\n    }\n    const hostSplit = result[4].split(':');\n    parsedUrl = {\n      protocol: result[1],\n      hostname: hostSplit[0],\n      port: hostSplit[1] || '',\n      pathname: result[5],\n      search: result[6],\n      hash: result[8]\n    };\n  }\n  if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {\n    parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);\n  }\n  return {\n    hostname: !serverBase && parsedUrl.hostname || '',\n    protocol: !serverBase && parsedUrl.protocol || '',\n    port: !serverBase && parsedUrl.port || '',\n    pathname: parsedUrl.pathname || '/',\n    search: parsedUrl.search || '',\n    hash: parsedUrl.hash || ''\n  };\n}\n/**\n * Provider for mock platform location config\n *\n * @publicApi\n */\nconst MOCK_PLATFORM_LOCATION_CONFIG = /*#__PURE__*/new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');\n/**\n * Mock implementation of URL state.\n *\n * @publicApi\n */\nlet MockPlatformLocation = /*#__PURE__*/(() => {\n  class MockPlatformLocation {\n    baseHref = '';\n    hashUpdate = new Subject();\n    popStateSubject = new Subject();\n    urlChangeIndex = 0;\n    urlChanges = [{\n      hostname: '',\n      protocol: '',\n      port: '',\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null\n    }];\n    constructor(config) {\n      if (config) {\n        this.baseHref = config.appBaseHref || '';\n        const parsedChanges = this.parseChanges(null, config.startUrl || 'http://_empty_/', this.baseHref);\n        this.urlChanges[0] = {\n          ...parsedChanges\n        };\n      }\n    }\n    get hostname() {\n      return this.urlChanges[this.urlChangeIndex].hostname;\n    }\n    get protocol() {\n      return this.urlChanges[this.urlChangeIndex].protocol;\n    }\n    get port() {\n      return this.urlChanges[this.urlChangeIndex].port;\n    }\n    get pathname() {\n      return this.urlChanges[this.urlChangeIndex].pathname;\n    }\n    get search() {\n      return this.urlChanges[this.urlChangeIndex].search;\n    }\n    get hash() {\n      return this.urlChanges[this.urlChangeIndex].hash;\n    }\n    get state() {\n      return this.urlChanges[this.urlChangeIndex].state;\n    }\n    getBaseHrefFromDOM() {\n      return this.baseHref;\n    }\n    onPopState(fn) {\n      const subscription = this.popStateSubject.subscribe(fn);\n      return () => subscription.unsubscribe();\n    }\n    onHashChange(fn) {\n      const subscription = this.hashUpdate.subscribe(fn);\n      return () => subscription.unsubscribe();\n    }\n    get href() {\n      let url = `${this.protocol}//${this.hostname}${this.port ? ':' + this.port : ''}`;\n      url += `${this.pathname === '/' ? '' : this.pathname}${this.search}${this.hash}`;\n      return url;\n    }\n    get url() {\n      return `${this.pathname}${this.search}${this.hash}`;\n    }\n    parseChanges(state, url, baseHref = '') {\n      // When the `history.state` value is stored, it is always copied.\n      state = JSON.parse(JSON.stringify(state));\n      return {\n        ...parseUrl(url, baseHref),\n        state\n      };\n    }\n    replaceState(state, title, newUrl) {\n      const {\n        pathname,\n        search,\n        state: parsedState,\n        hash\n      } = this.parseChanges(state, newUrl);\n      this.urlChanges[this.urlChangeIndex] = {\n        ...this.urlChanges[this.urlChangeIndex],\n        pathname,\n        search,\n        hash,\n        state: parsedState\n      };\n    }\n    pushState(state, title, newUrl) {\n      const {\n        pathname,\n        search,\n        state: parsedState,\n        hash\n      } = this.parseChanges(state, newUrl);\n      if (this.urlChangeIndex > 0) {\n        this.urlChanges.splice(this.urlChangeIndex + 1);\n      }\n      this.urlChanges.push({\n        ...this.urlChanges[this.urlChangeIndex],\n        pathname,\n        search,\n        hash,\n        state: parsedState\n      });\n      this.urlChangeIndex = this.urlChanges.length - 1;\n    }\n    forward() {\n      const oldUrl = this.url;\n      const oldHash = this.hash;\n      if (this.urlChangeIndex < this.urlChanges.length) {\n        this.urlChangeIndex++;\n      }\n      this.emitEvents(oldHash, oldUrl);\n    }\n    back() {\n      const oldUrl = this.url;\n      const oldHash = this.hash;\n      if (this.urlChangeIndex > 0) {\n        this.urlChangeIndex--;\n      }\n      this.emitEvents(oldHash, oldUrl);\n    }\n    historyGo(relativePosition = 0) {\n      const oldUrl = this.url;\n      const oldHash = this.hash;\n      const nextPageIndex = this.urlChangeIndex + relativePosition;\n      if (nextPageIndex >= 0 && nextPageIndex < this.urlChanges.length) {\n        this.urlChangeIndex = nextPageIndex;\n      }\n      this.emitEvents(oldHash, oldUrl);\n    }\n    getState() {\n      return this.state;\n    }\n    /**\n     * Browsers are inconsistent in when they fire events and perform the state updates\n     * The most easiest thing to do in our mock is synchronous and that happens to match\n     * Firefox and Chrome, at least somewhat closely\n     *\n     * https://github.com/WICG/navigation-api#watching-for-navigations\n     * https://docs.google.com/document/d/1Pdve-DJ1JCGilj9Yqf5HxRJyBKSel5owgOvUJqTauwU/edit#heading=h.3ye4v71wsz94\n     * popstate is always sent before hashchange:\n     * https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#when_popstate_is_sent\n     */\n    emitEvents(oldHash, oldUrl) {\n      this.popStateSubject.next({\n        type: 'popstate',\n        state: this.getState(),\n        oldUrl,\n        newUrl: this.url\n      });\n      if (oldHash !== this.hash) {\n        this.hashUpdate.next({\n          type: 'hashchange',\n          state: null,\n          oldUrl,\n          newUrl: this.url\n        });\n      }\n    }\n    static ɵfac = function MockPlatformLocation_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MockPlatformLocation)(i0.ɵɵinject(MOCK_PLATFORM_LOCATION_CONFIG, 8));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MockPlatformLocation,\n      factory: MockPlatformLocation.ɵfac\n    });\n  }\n  return MockPlatformLocation;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Mock implementation of URL state.\n */\nlet FakeNavigationPlatformLocation = /*#__PURE__*/(() => {\n  class FakeNavigationPlatformLocation {\n    _platformNavigation;\n    constructor() {\n      const platformNavigation = inject(PlatformNavigation);\n      if (!(platformNavigation instanceof _FakeNavigation)) {\n        throw new Error('FakePlatformNavigation cannot be used without FakeNavigation. Use ' + '`provideFakeNavigation` to have all these services provided together.');\n      }\n      this._platformNavigation = platformNavigation;\n    }\n    config = inject(MOCK_PLATFORM_LOCATION_CONFIG, {\n      optional: true\n    });\n    getBaseHrefFromDOM() {\n      return this.config?.appBaseHref ?? '';\n    }\n    onPopState(fn) {\n      this._platformNavigation.window.addEventListener('popstate', fn);\n      return () => this._platformNavigation.window.removeEventListener('popstate', fn);\n    }\n    onHashChange(fn) {\n      this._platformNavigation.window.addEventListener('hashchange', fn);\n      return () => this._platformNavigation.window.removeEventListener('hashchange', fn);\n    }\n    get href() {\n      return this._platformNavigation.currentEntry.url;\n    }\n    get protocol() {\n      return new URL(this._platformNavigation.currentEntry.url).protocol;\n    }\n    get hostname() {\n      return new URL(this._platformNavigation.currentEntry.url).hostname;\n    }\n    get port() {\n      return new URL(this._platformNavigation.currentEntry.url).port;\n    }\n    get pathname() {\n      return new URL(this._platformNavigation.currentEntry.url).pathname;\n    }\n    get search() {\n      return new URL(this._platformNavigation.currentEntry.url).search;\n    }\n    get hash() {\n      return new URL(this._platformNavigation.currentEntry.url).hash;\n    }\n    pushState(state, title, url) {\n      this._platformNavigation.pushState(state, title, url);\n    }\n    replaceState(state, title, url) {\n      this._platformNavigation.replaceState(state, title, url);\n    }\n    forward() {\n      this._platformNavigation.forward();\n    }\n    back() {\n      this._platformNavigation.back();\n    }\n    historyGo(relativePosition = 0) {\n      this._platformNavigation.go(relativePosition);\n    }\n    getState() {\n      return this._platformNavigation.currentEntry.getHistoryState();\n    }\n    static ɵfac = function FakeNavigationPlatformLocation_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FakeNavigationPlatformLocation)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: FakeNavigationPlatformLocation,\n      factory: FakeNavigationPlatformLocation.ɵfac\n    });\n  }\n  return FakeNavigationPlatformLocation;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FAKE_NAVIGATION = /*#__PURE__*/new InjectionToken('fakeNavigation', {\n  providedIn: 'root',\n  factory: () => {\n    const config = inject(MOCK_PLATFORM_LOCATION_CONFIG, {\n      optional: true\n    });\n    const baseFallback = 'http://_empty_/';\n    const startUrl = new URL(config?.startUrl || baseFallback, baseFallback);\n    const fakeNavigation = new _FakeNavigation(inject(DOCUMENT), startUrl.href);\n    fakeNavigation.setSynchronousTraversalsForTesting(true);\n    return fakeNavigation;\n  }\n});\n/**\n * Return a provider for the `FakeNavigation` in place of the real Navigation API.\n */\nfunction provideFakePlatformNavigation() {\n  return [{\n    provide: PlatformNavigation,\n    useFactory: () => inject(FAKE_NAVIGATION)\n  }, {\n    provide: PlatformLocation,\n    useClass: FakeNavigationPlatformLocation\n  }];\n}\n\n/**\n * A spy for {@link Location} that allows tests to fire simulated location events.\n *\n * @publicApi\n */\nlet SpyLocation = /*#__PURE__*/(() => {\n  class SpyLocation {\n    urlChanges = [];\n    _history = [new LocationState('', '', null)];\n    _historyIndex = 0;\n    /** @internal */\n    _subject = new Subject();\n    /** @internal */\n    _basePath = '';\n    /** @internal */\n    _locationStrategy = null;\n    /** @internal */\n    _urlChangeListeners = [];\n    /** @internal */\n    _urlChangeSubscription = null;\n    /** @docs-private */\n    ngOnDestroy() {\n      this._urlChangeSubscription?.unsubscribe();\n      this._urlChangeListeners = [];\n    }\n    setInitialPath(url) {\n      this._history[this._historyIndex].path = url;\n    }\n    setBaseHref(url) {\n      this._basePath = url;\n    }\n    path() {\n      return this._history[this._historyIndex].path;\n    }\n    getState() {\n      return this._history[this._historyIndex].state;\n    }\n    isCurrentPathEqualTo(path, query = '') {\n      const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n      const currPath = this.path().endsWith('/') ? this.path().substring(0, this.path().length - 1) : this.path();\n      return currPath == givenPath + (query.length > 0 ? '?' + query : '');\n    }\n    simulateUrlPop(pathname) {\n      this._subject.next({\n        'url': pathname,\n        'pop': true,\n        'type': 'popstate'\n      });\n    }\n    simulateHashChange(pathname) {\n      const path = this.prepareExternalUrl(pathname);\n      this.pushHistory(path, '', null);\n      this.urlChanges.push('hash: ' + pathname);\n      // the browser will automatically fire popstate event before each `hashchange` event, so we need\n      // to simulate it.\n      this._subject.next({\n        'url': pathname,\n        'pop': true,\n        'type': 'popstate'\n      });\n      this._subject.next({\n        'url': pathname,\n        'pop': true,\n        'type': 'hashchange'\n      });\n    }\n    prepareExternalUrl(url) {\n      if (url.length > 0 && !url.startsWith('/')) {\n        url = '/' + url;\n      }\n      return this._basePath + url;\n    }\n    go(path, query = '', state = null) {\n      path = this.prepareExternalUrl(path);\n      this.pushHistory(path, query, state);\n      const locationState = this._history[this._historyIndex - 1];\n      if (locationState.path == path && locationState.query == query) {\n        return;\n      }\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.urlChanges.push(url);\n      this._notifyUrlChangeListeners(path + _normalizeQueryParams(query), state);\n    }\n    replaceState(path, query = '', state = null) {\n      path = this.prepareExternalUrl(path);\n      const history = this._history[this._historyIndex];\n      history.state = state;\n      if (history.path == path && history.query == query) {\n        return;\n      }\n      history.path = path;\n      history.query = query;\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.urlChanges.push('replace: ' + url);\n      this._notifyUrlChangeListeners(path + _normalizeQueryParams(query), state);\n    }\n    forward() {\n      if (this._historyIndex < this._history.length - 1) {\n        this._historyIndex++;\n        this._subject.next({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true,\n          'type': 'popstate'\n        });\n      }\n    }\n    back() {\n      if (this._historyIndex > 0) {\n        this._historyIndex--;\n        this._subject.next({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true,\n          'type': 'popstate'\n        });\n      }\n    }\n    historyGo(relativePosition = 0) {\n      const nextPageIndex = this._historyIndex + relativePosition;\n      if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n        this._historyIndex = nextPageIndex;\n        this._subject.next({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true,\n          'type': 'popstate'\n        });\n      }\n    }\n    onUrlChange(fn) {\n      this._urlChangeListeners.push(fn);\n      this._urlChangeSubscription ??= this.subscribe(v => {\n        this._notifyUrlChangeListeners(v.url, v.state);\n      });\n      return () => {\n        const fnIndex = this._urlChangeListeners.indexOf(fn);\n        this._urlChangeListeners.splice(fnIndex, 1);\n        if (this._urlChangeListeners.length === 0) {\n          this._urlChangeSubscription?.unsubscribe();\n          this._urlChangeSubscription = null;\n        }\n      };\n    }\n    /** @internal */\n    _notifyUrlChangeListeners(url = '', state) {\n      this._urlChangeListeners.forEach(fn => fn(url, state));\n    }\n    subscribe(onNext, onThrow, onReturn) {\n      return this._subject.subscribe({\n        next: onNext,\n        error: onThrow ?? undefined,\n        complete: onReturn ?? undefined\n      });\n    }\n    normalize(url) {\n      return null;\n    }\n    pushHistory(path, query, state) {\n      if (this._historyIndex > 0) {\n        this._history.splice(this._historyIndex + 1);\n      }\n      this._history.push(new LocationState(path, query, state));\n      this._historyIndex = this._history.length - 1;\n    }\n    static ɵfac = function SpyLocation_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SpyLocation)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SpyLocation,\n      factory: SpyLocation.ɵfac\n    });\n  }\n  return SpyLocation;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass LocationState {\n  path;\n  query;\n  state;\n  constructor(path, query, state) {\n    this.path = path;\n    this.query = query;\n    this.state = state;\n  }\n}\n\n/**\n * A mock implementation of {@link LocationStrategy} that allows tests to fire simulated\n * location events.\n *\n * @publicApi\n */\nlet MockLocationStrategy = /*#__PURE__*/(() => {\n  class MockLocationStrategy extends LocationStrategy {\n    internalBaseHref = '/';\n    internalPath = '/';\n    internalTitle = '';\n    urlChanges = [];\n    /** @internal */\n    _subject = new Subject();\n    stateChanges = [];\n    constructor() {\n      super();\n    }\n    simulatePopState(url) {\n      this.internalPath = url;\n      this._subject.next(new _MockPopStateEvent(this.path()));\n    }\n    path(includeHash = false) {\n      return this.internalPath;\n    }\n    prepareExternalUrl(internal) {\n      if (internal.startsWith('/') && this.internalBaseHref.endsWith('/')) {\n        return this.internalBaseHref + internal.substring(1);\n      }\n      return this.internalBaseHref + internal;\n    }\n    pushState(ctx, title, path, query) {\n      // Add state change to changes array\n      this.stateChanges.push(ctx);\n      this.internalTitle = title;\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.internalPath = url;\n      const externalUrl = this.prepareExternalUrl(url);\n      this.urlChanges.push(externalUrl);\n    }\n    replaceState(ctx, title, path, query) {\n      // Reset the last index of stateChanges to the ctx (state) object\n      this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;\n      this.internalTitle = title;\n      const url = path + (query.length > 0 ? '?' + query : '');\n      this.internalPath = url;\n      const externalUrl = this.prepareExternalUrl(url);\n      this.urlChanges.push('replace: ' + externalUrl);\n    }\n    onPopState(fn) {\n      this._subject.subscribe({\n        next: fn\n      });\n    }\n    getBaseHref() {\n      return this.internalBaseHref;\n    }\n    back() {\n      if (this.urlChanges.length > 0) {\n        this.urlChanges.pop();\n        this.stateChanges.pop();\n        const nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : '';\n        this.simulatePopState(nextUrl);\n      }\n    }\n    forward() {\n      throw 'not implemented';\n    }\n    getState() {\n      return this.stateChanges[(this.stateChanges.length || 1) - 1];\n    }\n    static ɵfac = function MockLocationStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MockLocationStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MockLocationStrategy,\n      factory: MockLocationStrategy.ɵfac\n    });\n  }\n  return MockLocationStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass _MockPopStateEvent {\n  newUrl;\n  pop = true;\n  type = 'popstate';\n  constructor(newUrl) {\n    this.newUrl = newUrl;\n  }\n}\n\n/**\n * Returns mock providers for the `Location` and `LocationStrategy` classes.\n * The mocks are helpful in tests to fire simulated location events.\n *\n * @publicApi\n */\nfunction provideLocationMocks() {\n  return [{\n    provide: Location,\n    useClass: SpyLocation\n  }, {\n    provide: LocationStrategy$1,\n    useClass: MockLocationStrategy\n  }];\n}\nexport { MOCK_PLATFORM_LOCATION_CONFIG, MockLocationStrategy, MockPlatformLocation, SpyLocation, provideLocationMocks, provideFakePlatformNavigation as ɵprovideFakePlatformNavigation };\n//# sourceMappingURL=testing.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}